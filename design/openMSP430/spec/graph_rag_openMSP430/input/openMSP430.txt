openMSP430
Author: Olivier GIRARD
olgirard@gmail.com
Rev. 1.17
November 6, 2017 OpenCores Nov 6, 2017
www.opencores.org Rev 1.17 iiRevision History
Rev. Date Author Description 
1.0 August 4th, 2009 GIRARD First version.
1.1 August 30th, 2009 GIRARD Replaced “openMSP430.inc“ with 
“openMSP430_defines.v“
1.2 December 27th, 2009 GIRARD - Update file and directory description for hte FPGA 
projects (in particular, add the Altera project).
- Diverse minor updates.
1.3 December 29th, 2009 GIRARD - Renamed the “rom_*“ ports to “pmem_*“.
- Renamed the “ram_*“ ports to “dmem_*“.
- Renamed the “ROM_AWIDTH“ Verilog define to 
“PMEM_AWIDTH“.
- Renamed the “RAM_AWIDTH“ Verilog define to 
“DMEM_AWIDTH“.
- Prefixed all the verilog sub-modules of the 
openMSP430 core with “omsp_“.
- Diverse minor updates
1.4 January 12th, 2010 GIRARD - Added the “Integration and Connectivity“section.
1.5 March 7th, 2010 GIRARD - Add Hardware multiplier info.
- Added the “Area and Speed Analysis“ section.
1.6 August 1st, 2010 GIRARD - Update core configuration section.
- Expand the CPU selection table for msp430-gcc.
1.7 August 18th, 2010 GIRARD - Update CPU_ID description in the serial debug 
interface chapter..
1.8 March 1st, 2011 GIRARD - Update openmsp430-minidebug tool section.
- Add. Actel ProASIC3 example to the file and 
directory description section.
1.9 June 6th, 2011 GIRARD - General update to reflect the latest RTL 
implementation (cpu_en/dbg_en ports, configurable 
peripheral address space, software development tools 
update...)..
1.10 March 20th, 2012 GIRARD - Global update reflecting the ASIC support and 
corresponding configuration options.
1.11 July 15th, 2012 GIRARD - Add benchmark results
- Add custom memory size configuration
1.12 November 27th, 2012 GIRARD - Global update reflecting the I2C based serial debug 
interface update.
1.13 February 24th, 2013 GIRARD - Minor update to reflect new ASIC_CLOCKING 
option.
1.14 December 17th, 2013 GIRARD - Update with number of IRQs configuration option.-
- Move peripherals documentation to a dedicated 
chapter.
1.15 May 19th, 2015 GIRARD - Overall update to document the DMA interface.
1.16 Dec 5th, 2016 GIRARD - Fix typo in instruction length table.
1.17 Nov 6th, 2017 GIRARD - Fix typo (refered to ‘per_wen‘ instead of ‘per_we‘; 
corrected BCSCTLx/DCOCTL names & addresses).Contents
1. OVERVIEW................................................................................................................... 1
2. CORE.............................................................................................................................. 4
3. PERIPHERALS ........................................................................................................... 22
4. DMA INTERFACE ...................................................................................................... 33
5. SERIAL DEBUG INTERFACE ................................................................................. 43
6. INTEGRATION AND CONNECTIVITY ................................................................ 59
7. ASIC IMPLEMENTATION ...................................................................................... 77
8. AREA AND SPEED ANALYSIS ................................................................................ 94
9. SOFTWARE DEVELOPMENT TOOLS .................................................................. 98
10. FILE AND DIRECTORY DESCRIPTION ........................................................... 1111.
Overview
Introduction
The openMSP430 is a synthesizable 16bit microcontroller core written in Verilog. It is
compatible with Texas Instruments' MSP430 microcontroller family  and can execute the
code generated by an MSP430 toolchain in a near cycle accurate way.
The core comes with some peripherals ( 16x16 Hardware Multiplier , Watchdog, GPIO,
TimerA, generic templates), with a DMA interface, and most notably with a two-wire
Serial Debug Interface  supportingthe MSPGCC GNU Debugger (GDB) for in-system
software debugging.
While being fully FPGA friendly, this design is also particularly suited for ASIC
implementations (typically mixed signal ICs with strong area and low-power
requirements).
In a nutshell, the openMSP430 brings with it:
•Low area (8k-Gates), without hidden extra infrastructure overhead (memory
backbone, IRQ controller and watchdog timer are already included).
•Excellent code density.
•Good performances.
•Build-in power and clock management options.
•Multiple times Silicon Proven.
1
Download
Design
The complete tar archive of the project can be downloaded here (OpenCores account
required).
The following SVN command can be run from a console (or GUI): 
svn export http://opencores.org/ocsvn/openmsp430/openmsp430/trunk/ openmsp430  
Changelog
•The Core's ChangeLog lists the CPU updates
•The Tools' ChangeLog lists the Software development tools updates.
•Subscribe to the following RSS feed to keep yourself informed about ALL
updates.
Documentation
Being fully compatible with the original MSP430 architecture, TI's official
documentation is applicable: SLAU49F.PDF
In addition, the openMSP430 online documentation is also available in pdf.
Features & Limitations
Features
•Core:
•Full instruction set support.
•Interrupts: IRQs (x14, x30 or x62), NMI (x1).
•Low Power Modes (LPMx).
•Configurable memory size for both program and data.
•Scalable peripheral address space.
•DMA interface.
•Two-wire Serial Debug Interface (I2C or UART based) with GDB support
(Nexus class 3, w/o trace).
•FPGA friendly (option for single clock domain, no clock gate).
•ASIC friendly (options for full power & clock management support).
•Small size (Xilinx: 1650 LUTs / Altera: 1550 LEs / ASIC: 8k gates).
2•Peripherals:
•16x16 Hardware Multiplier.
•Basic Clock Module.
•Watchdog.
•Timer A (FPGA only).
•GPIO (FPGA only).
•Templates for 8 and 16 bit peripherals.
•Graphic Controller ( openGFX430).
Limitations
•Core:
•Instructions can't be executed from the data memory.
Links
Development has been performed using the following freely available (excellent) tools:
•Icarus Verilog : Verilog simulator.
•GTKWave Analyzer  : Waveform viewer.
•MSPGCC : GCC toolchain for the Texas Instruments MSP430 MCUs.
•ISE WebPACK : Xilinx's free FPGA synthesis tool.
A few MSP430 links:
•Wikipedia: MSP430  
•TI: MSP430x1xx Family User's Guide
•TI: MSP430 Competitive Benchmarking
•TI: a list of available MSP430 Open Source projects out there on the web today.  
Legal information
MSP430 is a trademark of Texas Instruments, Inc. This project is not affiliated in any
way with Texas Instruments. All other product names are trademarks or registered
trademarks of their respective owners.
32.
Core
Table of content
•1. Introduction
•2. Core
•2.1 Design structure
•2.2 Limitations
•2.3 Configuration
•2.3.1 Basic System Configuration
•2.3.2 Advanced System Configuration
•2.3.3 Expert System Configuration
•2.3.4 Parameters For Multi-Core Systems
•2.4 Memory mapping
•2.5 Interrupt mapping
•2.6   Pinout
•2.7   Instruction Cycles and Lengths
•2.8   Serial Debug Interface
•2.9   Benchmark results
•2.9  .1 Dhrystone
•2.9  .2 CoreMark
41. Introduction
The openMSP430 is a 16-bit microcontroller core compatible with TI's MSP430 family
(note that the extended version of the architecture, the MSP430X, isn't supported by this
IP). It is based on a V on Neumann architecture, with a single address space for
instructions and data.
Depending on the selected configuration, this design can either be:
•FPGA friendly: the core doesn't contain any clock gate and has only a single 
clock domain. As a consequence, in this mode, the Basic Clock Module  peripheral
has a few limitations.
•ASIC friendly: the core contains up to all clock management options (clock 
muxes & low-power modes, fine grained clock gating, …) and is also ready for 
scan insertion. In this mode, the Basic Clock Module  offers all features listed in 
the official documentation.
It is to be noted that this IP doesn't contain the instruction and data memory blocks
internally (these are technology dependent hard macros which are connected to the IP
during chip integration). However the core is fully configurable in regard to the supported
RAM and/or ROM sizes.
52. Core
2.1 Design structure
The following diagram shows the openMSP430 design structure:
•Frontend: This module performs the instruction Fetch and Decode tasks. It also 
contains the execution state machine.
•Execution unit: Containing the ALU and the register file, this module executes 
the current decoded instruction according to the execution state.
•Serial Debug Interface : Contains all the required logic for a Nexus class 3 
debugging unit (without trace). Communication with the host is done with a 
standard two-wire interface following either the UART 8N1 or I2C serial protocol.
•Memory backbone : This block performs a simple arbitration between the 
frontend, execution-unit, DMA and Serial-Debug interfaces for program, data and 
peripheral memory accesses.
•Basic Clock Module : Generates MCLK, ACLK, SMCLK and manage the low 
power modes.
6
•SFRs: The Special Function Registers block contains diverse configuration 
registers (NMI, Watchdog, ...).
•Watchdog: Although it is a peripheral, the watchdog is directly included in the 
core because of its tight links with the NMI interrupts and the PUC reset 
generation.
•16x16 Multiplier: The hardware multiplier peripheral is transparently supported  
by the GCC compiler and is therefore located in the core. It can be included or 
excluded at will through a Verilog define.
2.2 Limitations
The known core limitations are the following:
•Instructions can't be executed from the data memory.
2.3 Configuration
It is possible to configure the openMSP430 core through the openMSP430_defines.v  file
located in the rtl directory (see file and directory description ).
In this section, three sets of adjustable user parameters are discussed in order to
customize the core. A fourth set is available for ASIC specific options and will be
discussed in the ASIC implementation  section.
2.3.1 Basic System Configuration
The basic system can be adjusted with the following set of defines in order to match the
target system requirements.
//=====================================================================  
//=====================================================================  
//BASIC SYSTEM CONFIGURATION  
//=====================================================================  
//=====================================================================  
// 
// Note: the sum of program, data and peripheral memory spaces must not  
// exceed 64 kB 
// 
// Program Memory Size:  
//                     Uncomment the required memory size  
//-------------------------------------------------------  
//`define PMEM_SIZE_CUSTOM  
//`define PMEM_SIZE_59_KB  
//`define PMEM_SIZE_55_KB  
//`define PMEM_SIZE_54_KB  
//`define PMEM_SIZE_51_KB  
//`define PMEM_SIZE_48_KB  
//`define PMEM_SIZE_41_KB  
//`define PMEM_SIZE_32_KB  
//`define PMEM_SIZE_24_KB  
7//`define PMEM_SIZE_16_KB  
//`define PMEM_SIZE_12_KB  
//`define PMEM_SIZE_8_KB  
//`define PMEM_SIZE_4_KB  
`define PMEM_SIZE_2_KB  
//`define PMEM_SIZE_1_KB  
// Data Memory Size:  
//                  Uncomment the required memory size  
//-------------------------------------------------------  
//`define DMEM_SIZE_CUSTOM  
//`define DMEM_SIZE_32_KB  
//`define DMEM_SIZE_24_KB  
//`define DMEM_SIZE_16_KB  
//`define DMEM_SIZE_10_KB  
//`define DMEM_SIZE_8_KB  
//`define DMEM_SIZE_5_KB  
//`define DMEM_SIZE_4_KB  
//`define DMEM_SIZE_2p5_KB  
//`define DMEM_SIZE_2_KB  
//`define DMEM_SIZE_1_KB  
//`define DMEM_SIZE_512_B  
//`define DMEM_SIZE_256_B  
`define DMEM_SIZE_128_B  
// Include/Exclude Hardware Multiplier  
`define MULTIPLIER  
// Include/Exclude Serial Debug interface  
`define DBG_EN
The only design considerations at this stage are:
•Make sure that the program and data memories have the correct size :-P
•The sum of program, data and peripheral memory space MUST NOT exceed 
64kB.
Note: when selected, full custom memory sizes can be specified in the “Expert System
Configuration” section.
2.3.2 Advanced System Configuration
In this section, some additional features are available in order to match the needs of more
experienced users.
 
//============================================================================  
//============================================================================  
// ADVANCED SYSTEM CONFIGURATION (FOR EXPERIENCED USERS)  
//============================================================================  
//============================================================================  
//-------------------------------------------------------  
// Custom user version number  
//-------------------------------------------------------  
// This 5 bit field can be freely used in order to allow  
// custom identification of the system through the debug  
8// interface. 
// (see CPU_ID.USER_VERSION field in the documentation)  
//-------------------------------------------------------  
`define USER_VERSION 5'b00000
//-------------------------------------------------------
// Include/Exclude Watchdog timer
//-------------------------------------------------------
// When excluded, the following functionality will be
// lost:
//        - Watchog (both interval and watchdog modes)
//        - NMI interrupt edge selection
//        - Possibility to generate a software PUC reset
//-------------------------------------------------------
`define WATCHDOG
//-------------------------------------------------------
// Include/Exclude DMA interface support
//-------------------------------------------------------
//`define DMA_IF_EN
//-------------------------------------------------------
// Include/Exclude Non-Maskable-Interrupt support
//-------------------------------------------------------
`define NMI
//-------------------------------------------------------
// Number of available IRQs
//-------------------------------------------------------
// Indicates the number of interrupt vectors supported
// (16 ,32 or 64).
//-------------------------------------------------------
`define IRQ_16
//`define IRQ_32
//`define IRQ_64
//-------------------------------------------------------
// Input synchronizers
//-------------------------------------------------------
// In some cases, the asynchronous input ports might
// already be synchronized externally.
// If an extensive CDC design review showed that this
// is really the case,   the individual synchronizers
// can be disabled with the following defines.
//
// Notes:
//        - all three signals are all sampled in the MCLK domain
//
//        - the dbg_en signal reset the debug interface
//         when 0. Therefore make sure it is glitch free.
//
//-------------------------------------------------------
`define SYNC_NMI
//`define SYNC_CPU_EN
//`define SYNC_DBG_EN
//-------------------------------------------------------  
// Peripheral Memory Space:  
9//-------------------------------------------------------  
// The original MSP430 architecture map the peripherals  
// from 0x0000 to 0x01FF (i.e. 512B of the memory space).  
// The following defines allow you to expand this space  
// up to 32 kB (i.e. from 0x0000 to 0x7fff).  
// As a consequence, the data memory mapping will be  
// shifted up and a custom linker script will therefore  
// be required by the GCC compiler.  
//-------------------------------------------------------  
//`define PER_SIZE_CUSTOM  
//`define PER_SIZE_32_KB  
//`define PER_SIZE_16_KB  
//`define PER_SIZE_8_KB  
//`define PER_SIZE_4_KB  
//`define PER_SIZE_2_KB  
//`define PER_SIZE_1_KB  
`define PER_SIZE_512_B  
//-------------------------------------------------------
// Defines the debugger CPU_CTL.RST_BRK_EN reset value
// (CPU break on PUC reset)
//-------------------------------------------------------
// When defined, the CPU will automatically break after
// a PUC occurrence by default. This is typically useful
// when the program memory can only be initialized through
// the serial debug interface.
//-------------------------------------------------------
`define DBG_RST_BRK_EN
Design consideration at this stage are:
•Setting a peripheral memory space to something else than 512B will shift the data 
memory mapping up, which in turn will require the use of a custom linker script. 
If you don't know what a linker script is and if you don't want to know what it is, 
you should probably not modify this section.
•The sum of program, data and peripheral memory space MUST NOT exceed 
64kB.
Note: when selected, full custom peripheral memory space can be specified in the
“Expert System Configuration” section.
2.3.3 Expert  System Configuration
In this section, you will find configuration options which will be relevant for roughly
0.1% of the users (according to a highly reliable market analysis ;-) ).
//============================================================================  
//============================================================================  
// EXPERT SYSTEM CONFIGURATION ( !!!! EXPERTS ONLY !!!! )  
//============================================================================  
//============================================================================  
// 
10// IMPORTANT NOTE: Please update following configuration options ONLY if  
//                you have a good reason to do so... and if you know what  
//                you are doing :-P  
// 
//============================================================================  
//-------------------------------------------------------
// Select serial debug interface protocol
//-------------------------------------------------------
//    DBG_UART -> Enable UART (8N1) debug interface
//    DBG_I2C  -> Enable I2C debug interface
//-------------------------------------------------------
`define DBG_UART
//`define DBG_I2C
//-------------------------------------------------------
// Enable the I2C broadcast address
//-------------------------------------------------------
// For multicore systems, a common I2C broadcast address
// can be given to all oMSP cores in order to
// synchronously RESET, START, STOP, or STEP all CPUs
// at once with a single I2C command.
// If you have a single openMSP430 in your system,
// this option can stay commented-out.
//-------------------------------------------------------
//`define DBG_I2C_BROADCAST
//-------------------------------------------------------  
// Number of hardware breakpoint units (each unit contains  
// two hardware address breakpoints):  
// - DBG_HWBRK_0 -> Include hardware breakpoints unit 0  
// - DBG_HWBRK_1 -> Include hardware breakpoints unit 1  
// - DBG_HWBRK_2 -> Include hardware breakpoints unit 2  
// - DBG_HWBRK_3 -> Include hardware breakpoints unit 3  
//-------------------------------------------------------  
// Please keep in mind that hardware breakpoints only  
// make sense whenever the program memory is not an SRAM  
// (i.e. Flash/OTP/ROM/...) or when you are interested  
// in data breakpoints (btw. not supported by GDB).  
//-------------------------------------------------------  
//`define DBG_HWBRK_0  
//`define DBG_HWBRK_1  
//`define DBG_HWBRK_2  
//`define DBG_HWBRK_3  
//-------------------------------------------------------  
// Enable/Disable the hardware breakpoint RANGE mode  
//-------------------------------------------------------  
// When enabled this feature allows the hardware breakpoint  
// units to stop the cpu whenever an instruction or data  
// access lays within an address range.  
// Note that this feature is not supported by GDB.  
//-------------------------------------------------------  
//`define DBG_HWBRK_RANGE  
//-------------------------------------------------------
// Custom Program/Data and Peripheral Memory Spaces
11//-------------------------------------------------------
// The following values are valid only if the
// corresponding *_SIZE_CUSTOM defines are uncommented:
//
//  - *_SIZE   : size of the section in bytes.
//  - *_AWIDTH : address port width, this value must allow
//               to address all WORDS of the section
//               (i.e. the *_SIZE divided by 2)
//-------------------------------------------------------
// Custom Program memory (enabled with PMEM_SIZE_CUSTOM)
`define PMEM_CUSTOM_AWIDTH      10
`define PMEM_CUSTOM_SIZE      2048
// Custom Data memory    (enabled with DMEM_SIZE_CUSTOM)
`define DMEM_CUSTOM_AWIDTH       6
`define DMEM_CUSTOM_SIZE       128
// Custom Peripheral memory  (enabled with PER_SIZE_CUSTOM)
`define PER_CUSTOM_AWIDTH        8
`define PER_CUSTOM_SIZE        512
//-------------------------------------------------------
// ASIC version
//-------------------------------------------------------
// When uncommented, this define will enable the
// ASIC system configuration section (see below) and
// will activate scan support for production test.
//
// WARNING: if you target an FPGA, leave this define
//          commented.
//-------------------------------------------------------
//`define ASIC
Design consideration at this stage are:
•This is the expert section... so you know what your are doing, right ;-)
All remaining defines located after the ASIC section in the openMSP430_defines.v  file
are system constants and MUST NOT be edited.
2.3.4 Parameters For Multi-Core Systems
In addition to the define file, two Verilog parmaeters are available to facilitate software
development on multi-core systems.
For example, in a dual-core openMSP430 system, the cores can be instantiated as
following:
openMSP430 #(.INST_NR ( 0), .TOTAL_NR(1)) openMSP430_core_0 (  
... 
); 
openMSP430 #(.INST_NR ( 1), .TOTAL_NR(1)) openMSP430_core_1 (  
... 
);
12The values of these parameters are then directly accessible by software through the
CPU_NR register of the SFR peripheral.
For example, if both cores share the same program memory, the software can take
advantage of this information as following:
"... 
int main(void) { 
  if (CPU_NR==0x0100) { 
    main_core_0(); // Main routine call for core 0  
  } 
  if (CPU_NR==0x0101) { 
    main_core_1(); // Main routine call for core 1  
  } 
} 
…"
2.4 Memory mapping
As discussed earlier, the openMSP430 memory mapping is fully configurable.
The basic system configuration section allows to adjust program and data memory sizes
while keeping 100% compatibility with the pre-existing linker scripts provided by
MSPGCC (or any other toolchain for that matter).
However, an increasing number of users saw the 512B space available for peripherals in
the standard MSP430 architecture as a limitation. Therefore, the advanced system
configuration section gives the possibility to up-scale the reserved peripheral address
space anywhere between 512B and 32kB. As a consequence, the data memory space will
be shifted up, which means that the linker script of your favorite toolchain will have to be
modified accordingly.
The following schematic should hopefully summarize this:
13
2.5 Interrupt mapping
The number of supported interrupts is configurable with the IRQ_xx macros.
The interrupt vectors are then mapped as following:
14
2.6 Pinout
The full pinout of the openMSP430 core is provided in the following table:
Port NameDirect
ionWidthClock
DomainDescription
Clocks
cpu_en Input1<async>
or mclk4Enable CPU code execution 
(asynchronous and non-glitchy).
Set to 1 if unused.
dco_clk Input1-Fast oscillator (fast clock)
lfxt_clk Input1-Low frequency oscillator (typ. 32kHz) 
Set to 0 if unused.
mclk Output1-Main system clock 
aclk_en Output1mclkFPGA ONLY: ACLK enable 
smclk_en Output1mclkFPGA ONLY: SMCLK enable 
dco_enable Output1dco_clkASIC ONLY: Fast oscillator enable
dco_wkup Output1<async>ASIC ONLY: Fast oscillator wakeup 
(asynchronous)
lfxt_enable Output1lfxt_clkASIC ONLY: Low frequency oscillator 
enable
lfxt_wkup Output1<async>ASIC ONLY: Low frequency oscillator 
wakeup (asynchronous)
aclk Output1-ASIC ONLY: ACLK
smclk Output1-ASIC ONLY: SMCLK
wkup Input1<async>ASIC ONLY: System Wake-up 
(asynchronous and non-glitchy)
Set 0 if unused.
Resets 
puc_rst Output1mclkMain system reset
reset_n Input1<async>Reset Pin (active low, asynchronous and 
non-glitchy) 
Interrupts 
irq Input`IRQ_NR-21mclkMaskable interrupts (one-hot signal) 
nmi Input1<async>
or mclk4Non-maskable interrupt (asynchronous 
and non-glitchy) 
15Set to 0 if unused.
irq_acc OutputIRQ_NR-21mclkInterrupt request accepted (one-hot signal)
Program Memory interface  
pmem_addr Output`PMEM_
AWIDTH1 mclkProgram Memory address 
pmem_cen Output1mclkProgram Memory chip enable (low active)
pmem_din Output16mclkProgram Memory data input (optional2) 
pmem_dout Input16mclkProgram Memory data output 
pmem_wen Output2mclkProgram Memory write byte enable (low 
active) (optional2)
Data Memory interface  
dmem_addr Output`DMEM_
AWIDTH1 mclkData Memory address 
dmem_cen Output1mclkData Memory chip enable (low active) 
dmem_din Output16mclkData Memory data input 
dmem_dout Input16mclkData Memory data output 
dmem_wen Output2mclkData Memory write byte enable (low 
active) 
External Peripherals interface  
per_addr Output14mclkPeripheral address 
per_din Output16mclkPeripheral data input 
per_dout Input16mclkPeripheral data output 
per_en Output1mclkPeripheral enable (high active) 
per_we Output2mclkPeripheral write enable (high active) 
Direct Memory Access interface
dma_addr Input15mclkDirect Memory Access address
dma_din Input16mclkDirect Memory Access data input
dma_dout Output16mclkDirect Memory Access data output
dma_en Input1mclkDirect Memory Access enable
(high active)
dma_priority Input1mclkDirect Memory Access priority
(0:low / 1:high)
dma_ready Output1mclkDirect Memory Access is complete
dma_resp Output1mclkDirect Memory Access response
(0:Okay / 1: Error)
dma_we Input2mclkDirect Memory Access write byte enable 
16(high active)
dma_wkup Input1<async>ASIC ONLY: DMA Wake-up 
(asynchronous and non-glitchy)
Serial Debug interface  
dbg_en Input1<async>
or mclk4Debug interface enable (asynchronous) 3
dbg_freeze Output1mclkFreeze peripherals 
dbg_uart_txd Output1mclkDebug interface: UART TXD 
dbg_uart_rxd Input1<async>Debug interface: UART RXD 
(asynchronous)
dbg_i2c_addr Input7mclkDebug interface: I2C Address
dbg_i2c_broadcast Input7mclkDebug interface: I2C Broadcast Address 
(for multicore systems)
dbg_i2c_scl Input1<async>Debug interface: I2C SCL (asynchronous)
dbg_i2c_sda_in Input1<async>Debug interface: I2C SDA IN 
(asynchronous)
dbg_i2c_sda_out Output1mclkDebug interface: I2C SDA OUT
Scan
scan_enable Input1dco_clkASIC ONLY: Scan enable (active during 
scan shifting)
scan_mode Input1<stable>ASIC ONLY: Scan mode
1: This parameter is declared in the "openMSP430_defines.v" file and defines the 
RAM/ROM size or the number of interrupts vectors (16, 32 or 64).
2: These two optional ports can be connected whenever the program memory is a RAM. 
This will allow the user to load a program through the serial debug interface and to use 
software breakpoints.
3: When disabled, the debug interface is hold into reset (and clock gated in ASIC mode). 
As a consequence, the dbg_en port can be used to reset the debug interface without 
disrupting the CPU execution.
4: Clock domain is selectable through configuration in the “openMSP430_defines.v” file 
(see Advanced System Configuration).
Note: in the FPGA configuration, the ASIC ONLY signals must be left unconnected (for 
the outputs) and tied low (for the inputs).
172.7 Instruction Cycles and Lengths
Please note that a detailed description of the instruction and addressing modes can be 
found in the MSP430x1xx Family User's Guide  (Chapter 3).
The number of CPU clock cycles required for an instruction depends on the instruction 
format and the addressing modes used, not the instruction itself.
In the following tables, the number of cycles refers to the main clock ( MCLK). 
Differences with the original MSP430 are highlighted in green (the original value being 
red).
•Interrupt and Reset Cycles  
Action No. of CyclesLength of Instruction
Return from interrupt (RETI) 5 1
Interrupt accepted 6 -
WDT reset 4 -
Reset (!RST/NMI) 4 -
•Format-II (Single Operand) Instruction Cycles and Lengths
Addressing ModeNo. of CyclesLength of InstructionRRA, RRC, SWPB, SXT PUSHCALL
Rn 133 (4)1
@Rn 3441
@Rn+ 34 (5)4 (5)1
#N N/A 452
X(Rn) 4552
EDE 4552
&EDE 4552
•Format-III (Jump) Instruction Cycles and Lengths
All jump instructions require one code word, and take two CPU cycles to execute, 
regardless of whether the jump is taken or not. 
18•Format-I (Double Operand) Instruction Cycles and Lengths  
Addressing ModeNo. of CyclesLength of InstructionSrcDst
RnRm1 1
PC2 1
x(Rm)4 2
EDE4 2
&EDE4 2
@RnRm2 1
PC3 (2) 1
x(Rm)5 2
EDE5 2
&EDE5 2
@Rn+Rm2 1
PC3 1
x(Rm)5 2
EDE5 2
&EDE5 2
#NRm2 2
PC3 2
x(Rm)5 3
EDE5 3
&EDE5 3
x(Rn)Rm3 2
PC4 (3) 2
x(Rm)6 3
EDE6 3
&EDE6 3
EDERm3 2
PC4 (3) 2
x(Rm)6 3
EDE6 3
&EDE6 3
19&EDERm3 2
PC4 (3) 2
x(Rm)6 3
EDE6 3
&EDE6 3
2.8 Serial Debug Interface
All the details about the Serial Debug Interface are located here. 
2.9 Benchmark results
2.9.1 Dhrystone (DMIPS/MHz)
Dhrystone is known for being susceptible to compiler optimizations (among other issues).
However, as it is still quite a popular metric, some results are provided here (ranging
from 0.30 to 0.45 DMIPS/MHz depending on the compiler version and options).
Note that the used C-code is available in the repository  here and here.
Dhrystone flavorCompiler options
-Os-O2-O3
Compiler version
Dhrystone v2.1
(common version)mspgcc v4.4.5 0.300.320.33
mspgcc v4.6.3 0.370.390.40
mspgcc v4.7.2 0.370.370.37
msp430-elf v4.9.1 0.260.360.37
Dhrystone v2.1
(MCU adapted)mspgcc v4.4.5 0.300.300.31
mspgcc v4.6.3 0.370.440.45
mspgcc v4.7.2 0.370.440.45
msp430-elf v4.9.1 0.260.360.37
202.9.2 CoreMark (Coremark/MHz)
CoreMark tries to address most of Dhrystone's pitfall by preventing the compiler to
optimize some code away and using "real-life" algorithm.
Note that the used C-code is available in the repository  here.
Compiler options
-Os-O2-O3
Compiler version
CoreMark v1.0
(official version)mspgcc v4.4.5 0.780.850.83
mspgcc v4.6.3 0.740.910.87
mspgcc v4.7.2 0.670.930.90
msp430-elf v4.9.1 0.580.67n.a.
213.
Peripherals
Table of content
•1. Introduction
•2. Peripherals
•2.1   System Peripherals
•2.1  .1 Basic Clock Module: FPGA
•2.1  .2 Basic Clock Module: ASIC
•2.1  .3 SFR
•2.1  .4 Watchdog Timer
•2.1  .5 16x16 Hardware Multiplier
•2.2   External Peripherals
•2.2  .1 Digital I/O (FPGA ONLY)
•2.3.2 Timer A (FPGA ONLY)
221. Introduction
In addition to the CPU core itself, several peripherals are also provided and can be easily
connected to the core during integration.
2. Peripherals
2.1 System Peripherals
In addition to the CPU core itself, several peripherals are also provided and can be easily 
connected to the core during integration. The followings are directly integrated within the
core because of their tight links with the CPU.
It is to be noted that ALL system peripherals support both ASIC and FPGA versions.
2.1.1 Basic Clock Module: FPGA
In order to make an FPGA implementation as simple as possible (ideally, a non-
professional designer should be able to do it), clock gates are not used in the design 
configuration and neither are clock muxes.
With these constrains, the Basic Clock Module is implemented as following:
23
Note: CPUOFF doesn't switch MCLK off and will instead bring the CPU state machines 
in an IDLE state while MCLK will still be running.
In order to 'clock' a register with ACLK or SMCLK, the following structure needs to be 
implemented:
For example, the following Verilog code would implement a counter clocked with 
SMCLK:
reg [7:0] test_cnt;
always @ (posedge mclk or posedge puc_rst)
if (puc_rst) test_cnt <= 8'h00;
else if (smclk_en) test_cnt <= test_cnt + 8'h01;
Register Description (FPGA)
Register
NameAddressBit Fields
76543210
DCOCTL0x0056 not implemented
BCSCTL10x0057unusedDIV Ax unused
BCSCTL20x0058unusedSELSDIVSxunused
•BCSCTL1.DIV Ax: ACLK_EN divider (1/2/4/8)
•BCSCTL2.SELS: SMCLK_EN clock selection (0:DCO_CLK / 1:LFXT_CLK)
•BCSCTL2.DIVSx: SMCLK_EN divider (1/2/4/8)
24
2.1.2 Basic Clock Module: ASIC
When targeting an ASIC, up to all clock management options available in the 
MSP430x1xx Family User's Guide  (Chapter 4) can be included:
Additional info can be found in the ASIC implementation  section.
25
Register Description (ASIC)
Register
NameAddressBit Fields
76543210
DCOCTL0x0056 not implemented
BCSCTL10x0057unusedDIV AxDMA_SCG1DMA_SCG0DMA_OSCOFFDMA_CPUOFF
BCSCTL20x0058SELMxunusedDIVMxSELSDIVSxunused
•BCSCTL1.DIV Ax : ACLK divider (1/2/4/8)
•BCSCTL1.DMA_SCG1 : Restore SMCLK with DMA wakeup
•BCSCTL1.DMA_SCG0 : Restore DCO oscillator with DMA wakeup
•BCSCTL1.DMA_OSCOFF : Restore LFXT oscillator with DMA wakeup
•BCSCTL1.DMA_CPUOFF : Restore MCLK with DMA wakeup
•BCSCTL2.SELMx : MCLK clock selection (0:DCO_CLK / 1:LFXT_CLK)
•BCSCTL2.DIVMx : MCLK clock divider (1/2/4/8)
•BCSCTL2.SELS : SMCLK clock selection (0:DCO_CLK / 1:LFXT_CLK)
•BCSCTL2.DIVSx : SMCLK clock divider (1/2/4/8)
262.1.3 SFR
Following the MSP430x1xx Family User's Guide , this peripheral implements flags and 
interrupt enable bits for the Watchdog Timer and NMI:
Register
NameAddressBit Fields
76543210
IE10x0000ReservedNMIIE 1ReservedWDTIE 2
IFG10x0002ReservedNMIIFG 1ReservedWDTIFG 2
1: These fields are not available if the NMI is excluded (see openMSP430_defines.v  )
2: These fields are not available if the Watchdog is excluded (see 
openMSP430_defines.v  )
In addition, two 16-bit read-only registers have been added in order to let the software 
know with which version of the openMSP430 it is running:
Register
NameAddressBit field
1514131211109876543210
CPU_ID_LO0x0004PER_SPACE USER_VERSIONASICCPU_VERSION
CPU_ID_HI0x0006PMEM_SIZE DMEM_SIZE MPY
CPU_NR0x0008CPU_TOTAL_NR CPU_INST_NR
•CPU_VERSION: Current CPU version.
•ASIC : Defines if the ASIC specific features are enabled in the
current openMSP430 implementation.
•USER_VERSION : Reflects the value defined in the openMSP430_defines.v
file.
•PER_SPACE : Peripheral address space for the current implementation
(byte size = PER_SPACE*512)
•MPY : This bit is set if the hardware multiplier is inclued in the
current implementation.
•DMEM_SIZE : Data memory size for the current implementation
(byte size = DMEM_SIZE*128)
•PMEM_SIZE : Program memory size for the current implementation
 (byte size = PMEM_SIZE*1024)
•CPU_INST_NR : Current oMSP instance number (for multicore systems)
•CPU_TOTAL_NR : Total number of oMSP instances-1 (for multicore systems)
27Note: attentive readers will have noted that CPU_ID_LO, CPU_ID_HI and CPU_NR are 
identical to the Serial Debug Interface register counterparts.
2.1.4 Watchdog Timer
100% of the features advertised in the MSP430x1xx Family User's Guide  (Chapter 10) 
have been implemented.
The following parameter in the openMSP430_defines.v  file controls if the watchdog timer
should be included or not:
//-------------------------------------------------------
// Include/Exclude Watchdog timer
//-------------------------------------------------------
// When excluded, the following functionality will be
// lost:
//        - Watchdog (both interval and watchdog modes)
//        - NMI interrupt edge selection
//        - Possibility to generate a software PUC reset
//-------------------------------------------------------
`define WATCHDOG
2.1.5 16x16 Hardware Multiplier
100% of the features advertised in the MSP430x1xx Family User's Guide  (Chapter 7) 
have been implemented.
The following parameter in the openMSP430_defines.v  file controls if the hardware 
multiplier should be included or not:
// Include/Exclude Hardware Multiplier
`define MULTIPLIER
282.2 External Peripherals
The external peripherals labeled with the “FPGA ONLY” tag do not contain any clock 
gate nor clock muxes and are clocked with MCLK only. This mean that they don't 
support any of the low power modes and therefore are most likely not suited for an ASIC 
implementation.
2.2.1 Digital I/O (FPGA ONLY)
100% of the features advertised in the MSP430x1xx Family User's Guide  (Chapter 9) 
have been implemented.
The following Verilog parameters will enable or disable the corresponding ports in order 
to save area (i.e. FPGA utilization):
parameter P1_EN = 1'b1; // Enable Port 1
parameter P2_EN = 1'b1; // Enable Port 2
parameter P3_EN = 1'b0; // Enable Port 3
parameter P4_EN = 1'b0; // Enable Port 4
parameter P5_EN = 1'b0; // Enable Port 5
parameter P6_EN = 1'b0; // Enable Port 6
They can be updated as following during the module instantiation (here port 1, 2 and 3 
are enabled):
gpio #(.P1_EN(1),
.P2_EN(1),
.P3_EN(1),
.P4_EN(0),
.P5_EN(0),
.P6_EN(0)) gpio_0 (
The full pinout of the GPIO module is provided in the following table:
Port NameDirectionWidth Description
Clocks & Resets
mclk Input1Main system clock 
puc_rstInput1Main system reset 
Interrupts
29irq_port1 Output1Port 1 interrupt 
irq_port2 Output1Port 2 interrupt 
External Peripherals interface
per_addr Input8Peripheral address 
per_din Input16Peripheral data input 
per_dout Output16Peripheral data output 
per_en Input1Peripheral enable (high active) 
per_we Input2Peripheral write enable (high active) 
Port 1
p1_din Input8Port 1 data input 
p1_dout Output8Port 1 data output 
p1_dout_en Output8Port 1 data output enable 
p1_sel Output8Port 1 function select 
Port 2
p2_din Input8Port 2 data input 
p2_dout Output8Port 2 data output 
p2_dout_en Output8Port 2 data output enable 
p2_sel Output8Port 2 function select 
Port 3
p3_din Input8Port 3 data input 
p3_dout Output8Port 3 data output 
p3_dout_en Output8Port 3 data output enable 
p3_sel Output8Port 3 function select 
Port 4
p4_din Input8Port 4 data input 
p4_dout Output8Port 4 data output 
p4_dout_en Output8Port 4 data output enable 
p4_sel Output8Port 4 function select 
Port 5
p5_din Input8Port 5 data input 
p5_dout Output8Port 5 data output 
p5_dout_en Output8Port 5 data output enable 
p5_sel Output8Port 5 function select 
Port 6
30p6_din Input8Port 6 data input 
p6_dout Output8Port 6 data output 
p6_dout_en Output8Port 6 data output enable 
p6_sel Output8Port 6 function select 
2.2.2 Timer A (FPGA ONLY)
100% of the features advertised in the MSP430x1xx Family User's Guide  (Chapter 11) 
have been implemented. 
The full pinout of the Timer A module is provided in the following table: 
Port NameDirectionWidth Description
Clocks, Resets & Debug
mclk Input1Main system clock 
aclk_en Input1ACLK enable (from CPU) 
smclk_en Input1SMCLK enable (from CPU) 
inclk Input1INCLK external timer clock (SLOW) 
taclk Input1TACLK external timer clock (SLOW) 
puc_rst Input1Main system reset 
dbg_freeze Input1Freeze Timer A counter 
Interrupts
irq_ta0 Output1Timer A interrupt: TACCR0 
irq_ta1 Output1Timer A interrupt: TAIV , TACCR1, TACCR2 
irq_ta0_acc Input1Interrupt request TACCR0 accepted 
External Peripherals interface
per_addr Input8Peripheral address 
per_din Input16Peripheral data input 
per_dout Output16Peripheral data output 
per_en Input1Peripheral enable (high active) 
per_we Input2Peripheral write enable (high active) 
Capture/Compare Unit 0
ta_cci0a Input 1 Timer A capture 0 input A 
ta_cci0b Input 1 Timer A capture 0 input B 
ta_out0 Output 1 Timer A output 0 
ta_out0_en Output 1 Timer A output 0 enable 
31Capture/Compare Unit 1
ta_cci1a Input1Timer A capture 1 input A 
ta_cci1b Input1Timer A capture 1 input B 
ta_out1 Output1Timer A output 1 
ta_out1_en Output1Timer A output 1 enable 
Capture/Compare Unit 2
ta_cci2a Input1Timer A capture 2 input A 
ta_cci2b Input1Timer A capture 2 input B 
ta_out2 Output1Timer A output 2 
ta_out2_en Output1Timer A output 2 enable 
Note: for the same reason as with the Basic Clock Module FPGA version, the two 
additional clock inputs (TACLK and INCLK) are internally synchronized with the 
MCLK domain. As a consequence, TACLK and INCLK should be at least 2 times 
slowlier than MCLK, and if these clock are used toghether with the Timer A output unit, 
some jitter might be observed on the generated output. If this jitter is critical for the 
application, ACLK and INCLK should idealy be derivated from DCO_CLK.
324.  
DMA Interface
Table of content
•1. Introduction
•2. Signal list
•3. Protocol
•3.1 Simple transfer
•3.2 Transfer with wait states
•3.3 Multiple transfers
•3.4     Transfer response
•3.5     Priority control
•3.5  .1 Data rate control
•3.5  .2 Bootloader case
•4 ASIC Implementation
•4.1 Clock domains
•4.2 DMA wakeup
331. Introduction
The openMSP430 Direct-Memory-Access interface acts as a gateway to the whole logical
64kB memory space and can be enabled be uncommenting the DMA_IF_EN macro in 
the "openMSP430_defines.sv"  file:
//-------------------------------------------------------
// Include/Exclude DMA interface support
//-------------------------------------------------------
//`define DMA_IF_EN
It supports the efficient connection of Bootloader, DMA controller, Memory-BIST or any 
other hardware unit requiring direct read/write access to the CPU memory space.  
The interface is also designed as to reuse the existing arbitration logic within the 
memory-backbone and thus minimize to timing costs of its physical implementation (i.e. 
no additional muxing layer on an already critical timing path).  
An simple system using the DMA interface typically consists of a DMA master directly 
connected to openMSP430 core:
34
However, it is also possible to combine different DMA masters using a custom arbitration
logic: 
2. Signal list
NameSourceType Description
MCLK
System clockopenMSP430SystemThis clock times all DMA transfers. All
signal timings are related to the rising
edge of MCLK.
PUC_RST
System resetopenMSP430SystemThe system reset is active HIGH and is
used to reset the sytem, including the
DMA master(s).
DMA_WKUP
WakeupDMA Master
(Asynchronous)SystemWhen HIGH in a Low-Power-Mode, the
wakeup signal restores the clocks
necessary for the DMA transfer
(see ASIC Implementation  section).
DMA_ADDR[15:1]
Address busDMA MasterAdressThis is the 15-bit address bus allowing to
access the 64kB address space (16b
words).
DMA_DIN[15:0]
Write data busDMA MasterDataThe write data bus is used to transfer
data from the D M A mas ter to
openMSP430 system during write
operations.
DMA_DOUT[15:0]
Read data busopenMSP430DataThe read data bus is used to transfer data
from the openMSP430 system to the
DMA master during read operations.
DMA_EN
Transfer enableDMA MasterControlIndicates that the current DMA transfer
is active.
35
DMA_WE[1:0]
Transfer directionDMA MasterControlWhen HIGH, this signal indicates a write
transfer on the selected byte, and a read
transfer when LOW.
DMA_PRIORITY
Transfer priorityDMA MasterControlWhen HIGH, this signal indicates a high
priority DMA transfer (i.e. CPU is
stopped). When LOW, low priority DMA
transfer have to wait for the CPU to free
the accessed ressource.
DMA_READY
Transfer doneopenMSP430ResponseWhen HIGH the DMA_READY signal
indicates that a transfer has finished on
the bus. This signal may be driven LOW
to add wait states to the transfer.
DMA_RESP
Transfer responseopenMSP430ResponseThe transfer response provides additional
information on the status of a transfer
(OKAY if LOW, ERROR when HIGH).
 
3. Protocol
3.1 Simple transfers
The following figure shows the simplest transfer, one with no wait states.
36
In a simple transfer with no wait states:
•The DMA master drives the address, control signals and write data onto the bus 
after the rising edge of MCLK.
•The openMSP430 ressource (pmem/dmem/peripheral) then samples the address, 
control and write data information on the next rising edge of the clock.
•For read access, after the openMSP430 ressource has sampled the address and 
control it can start to drive the read data and this is sampled by the DMA master 
on the third rising edge of the clock.
3.2 Transfer with wait states
The openMSP430 can insert wait states into any transfer, as shown in the following 
figure, which extends the transfer by two clock cycles, thus taking additional time for 
completion. 
For both read and write operations the DMA master must hold the address, control and 
write data stable throughout the extended cycles.  
Note: wait states are inserted by the openMSP430 if the CPU is currently busy reading or
writing to the same ressource that the DMA controller also wants to access.  
37
3.3 Multiple transfers
The following figure shows three transfers to unrelated addresses, A, B & C.  
We can here observe:
•the transfers to addresses A and C are both zero wait state.
•the transfer to address B is one wait state.
•the read data from A is available during the  first clock cycle when the address and
control B are applied.
•the read data from B is available during the clock cycle when the address and 
control C are applied.
3.4 Transfer response
The following figure shows two transfers to unrelated addresses, A & B.  
38
We can here observe:
•the transfer to address A returns an ERROR response (note that transfer returning 
an ERROR response  never have wait states).
•the transfer to address B is a regular transfer (i.e. OKAY response) without wait 
state.
Note: an ERROR response are generated if the transfer address lays between the program
and data memories, where nothing is mapped.  
3.5 Priority control
3.5.1 Data rate control
The DMA_PRIORITY control signal is available to the DMA master for controlling the 
application data rate requirements.
•When CLEARED, DMA transfers have a  fixed lower priority  than the CPU. This
means that depending on the exact kind of instructions currently executed by the 
CPU, the completion time of the DMA transfers cannot be predicted (i.e. DMA 
transfers are completed only when the CPU is not accessing the trageted 
ressource).
•When SET, DMA transfers have a  fixed higher priority  over the CPU. This 
means that the CPU will will stop execution and give the full bandwidth to the 
DMA controller. In that scenario, DMA transfers complete in a single clock cycle 
(i.e. without any wait states), as the targeted ressources are always available (i.e. 
the CPU is not executing).
•If the application requirements need something in between (namely a minimum 
DMA transfer data-rate with reduced effect on the firmware exection), then the 
DMA master can dynamically change the DMA_PRIORITY as required.
These scenario are illustrated in the following figure.  
We can here observe:
•Phase A illustrates LOW-PRIORITY transfers. Less DMA transfer are completed
during that time as shown by the number of wait states.
39
•Phase B illustrates HIGH-PRIORITY transfers. DMA transfers are completed
with each clock cycle (i.e. no wait state).
•Phase C illustrates MIXED-PRIORITY transfers where the DMA controller is
dynamically adjusting the priority to achieve its target minimum data-rate.
3.5.2 Bootloader case
In general, the purpose of a bootloader is to initialize the program memory at startup (i.e 
after Power-On-Reset).
DMA transfers driven by the bootloader should therefore be performed in HIGH-
PRIORITY mode, as the CPU should not start executing instructions on a non-initialized 
memory.
Once the memory initialization is completed, a reset pulse should be generated by the 
bootloader to make sure the CPU re-fetches the new RESET vector from the program 
memory.
A bootloader could be for example be connected as following:
The bootloading sequence is illustrated in the following figure:  
40
4. ASIC Implementation
4.1 Clock domains
If the ASIC low power options are enabled, it is possible to perform DMA accesses when 
the main CPU is in  any Low-Power-Mode (LPMx).
However, in order to avoid unnecessary power consumption while restoring the clocks 
for the DMA transfer, the MCLK system clock has been split into two clock domains.
•MCLK_CPU : clocks the CPU core itself, namely the frontend and execution 
logic. When the CPU is in LPMx mode, this clock is ALWAYS OFF, even if a 
DMA transfer is currently on going.
•MCLK_DMA : clocks the rest of the system (excluding the DBG interface) and 
gives access to the 64kB memory adddress range to the DMA master. This clock 
is restored in LPMx modes by asserting the DMA_WKUP pin.
This table summarizes the clock operating modes:
Clock NameCPU is ActiveCPU in Low-Power-Mode
DMA_WKUP=0 DMA_WKUP=1
MCLK_CPU ONOFF OFF
MCLK_DMA ONOFF ON
Clock domains are illustrated in the following diagram:
41
4.2 DMA wakeup
As shown in the "Peripherals" chapter, the Basic-Clock-Module has several control 
registers giving some flexibility to the firmware as to which clocks are restored when the 
DMA_WKUP pin is asserted.
Register
NameAddressBit Fields
76543210
BCSCTL10x0057unusedDIV AxDMA_SCG1DMA_SCG0DMA_OSCOFFDMA_CPUOFF
•DMA_SCG1    : Restore SMCLK with DMA wakeup
•DMA_SCG0    : Restore DCO oscillator with DMA wakeup
•DMA_OSCOFF : Restore LFXT oscillator with DMA wakeup
•DMA_CPUOFF : Restore MCLK_DMA with DMA wakeup
Note that the DMA_WKUP functionality can be disabled by keeping all these 
bitfields CLEARED. 
425.  
Serial Debug Interface
Table of content
•1. Introduction
•2. Debug Unit
•2.1 Register Mapping
•2.2 CPU Control/Status Registers
•2.2.1 CPU_ID
•2.2.2 CPU_CTL
•2.2.3 CPU_STAT
•2.2.4 CPU_NR
•2.3 Memory Access Registers
•2.3.1 MEM_CTL
•2.3.2 MEM_ADDR
•2.3.3 MEM_DATA
•2.3.4 MEM_CNT
•2.4 Hardware Breakpoint Unit Registers
•2.4.1 BRKx_CTL
•2.4.2 BRKx_STAT
•2.4.3 BRKx_ADDR0
•2.4.4 BRKx_ADDR1
•3. Debug Communication Interface: UART
•3.1 Serial communication protocol: 8N1
•3.2 Synchronization frame
•3.3 Read/Write access to the debug registers
•3.3.1 Command Frame
•3.3.2 Write access
•3.3.3 Read access
•3.4 Read/Write burst implementation for the CPU Memory access
•3.4.1 Write Burst access
•3.4.2 Read Burst access
43•4. Debug Communication Interface: I2C
•4.1 I2C communication protocol
•4.2 Synchronization frame
•4.3 Read/Write access to the debug registers
•4.3.1 Command Frame
•4.3.2 Write access
•4.3.3 Read access
•4.4 Read/Write burst implementation for the CPU Memory access
•4.4.1 Write Burst access
•4.4.2 Read Burst access
1. Introduction
The original MSP430 from TI provides a serial debug interface to allow in-system 
software debugging. In that case, the communication with the host computer is typically 
built on a JTAG or Spy-Bi-Wire serial protocol. However, the global debug architecture 
from the MSP430 is unfortunately poorly documented on the web (and is also probably 
tightly linked with the internal core architecture).
A custom module has therefore been implemented for the openMSP430. The 
communication with the host is done with a simple two-wire cable following either the 
UART or I2C serial protocol (interface is selectable in the Expert System Configuration  
section).
The debug unit provides all required features for Nexus Class 3 debugging (beside trace), 
namely:
Debug unit features
•CPU control (run, stop, step, reset).
•Software & hardware breakpoint support.
•Hardware watchpoint support.
•Memory read/write on-the-fly (no need to halt 
execution).
•CPU registers read/write on-the-fly (no need to halt 
execution).
Depending on the selected serial interface, the following features are available:
44Debug unit features
UART I2C
Strengths:
•No extra hardware required for 
most FPGA boards (almost all 
come with a UART interface, 
either RS232 or USB based.
•Possibility to use USB to serial 
TTL cables.
Weaknesses:
•Need to reset the debug interface 
after cable insertion.
•For ASICs, no possibility to 
change the MCLK frequency 
during a debug session.Strengths:
•Very stable interface (synchronous 
protocol, no synchronization frame 
required).
•Multi-core chip support with a single 
I2C interface (i.e. TWO pins)... in 
such a system, each openMSP430 
instance has its own I2C device 
address.
•Possibility to combine the 
openMSP430 debug interface with an
already existing “functional” I2C 
interface... effectively creating a 
ZERO wire serial debug interface.
•Affordable USB-ISS adapter (≈23€).
Weaknesses:
•Extra I2C adapter required ( USB-ISS
currently supported).
2. Debug Unit
2.1 Register Mapping
The following table summarize the complete debug register set accessible through the 
debug communication interface:
Register NameAddressBit Field
1514131211109876543210
CPU_ID_LO0x00PER_SPACE USER_VERSION ASICCPU_VERSION
CPU_ID_HI0x01PMEM_SIZE DMEM_SIZE MPY
CPU_CTL0x02ReservedCPU_RSTRST_BRK_ENFRZ_BRK_ENSW_BRK_ENISTEPRUNHALT
CPU_STAT0x03ReservedHWBRK3_PNDHWBRK2_PNDHWBRK1_PNDHWBRK0_PNDSWBRK_PNDPUC_PNDRes.HALT_RUN
MEM_CTL0x04 Reserved B/WMEM/REGRD/WRSTART
MEM_ADDR0x05 MEM_ADDR[15:0]
MEM_DATA0x06 MEM_DATA[15:0]
MEM_CNT0x07 MEM_CNT[15:0]
BRK0_CTL0x08 Reserved RANGE_MODEINST_ENBREAK_ENACCESS_MODE
BRK0_STAT0x09 Reserved RANGE_WRRANGE_RDADDR1_WRADDR1_RDADDR0_WRADDR0_RD
BRK0_ADDR00x0A BRK_ADDR0[15:0]
BRK0_ADDR10x0B BRK_ADDR1[15:0]
45BRK1_CTL0x0C Reserved RANGE_MODEINST_ENBREAK_ENACCESS_MODE
BRK1_STAT0x0D Reserved RANGE_WRRANGE_RDADDR1_WRADDR1_RDADDR0_WRADDR0_RD
BRK1_ADDR00x0E BRK_ADDR0[15:0]
BRK1_ADDR10x0F BRK_ADDR1[15:0]
BRK2_CTL0x10 Reserved RANGE_MODEINST_ENBREAK_ENACCESS_MODE
BRK2_STAT0x11 Reserved RANGE_WRRANGE_RDADDR1_WRADDR1_RDADDR0_WRADDR0_RD
BRK2_ADDR00x12 BRK_ADDR0[15:0]
BRK2_ADDR10x13 BRK_ADDR1[15:0]
BRK3_CTL0x14 Reserved RANGE_MODEINST_ENBREAK_ENACCESS_MODE
BRK3_STAT0x15 Reserved RANGE_WRRANGE_RDADDR1_WRADDR1_RDADDR0_WRADDR0_RD
BRK3_ADDR00x16 BRK_ADDR0[15:0]
BRK3_ADDR10x17 BRK_ADDR1[15:0]
CPU_NR0x18CPU_TOTAL_NR CPU_INST_NR
2.2 CPU Control/Status Registers
2.2.1 CPU_ID
This 32 bit read-only register holds the program and data memory size information of the 
implemented openMSP430. 
Register NameAddressBit Field
1514131211109876543210
CPU_ID_LO0x00PER_SPACE USER_VERSIONASICCPU_VERSION
CPU_ID_HI0x01PMEM_SIZE DMEM_SIZE MPY
• CPU_VERSION: Current CPU version
• ASIC : Defines if the ASIC specific features are enabled in the current 
openMSP430 implementation.
• USER_VERSION: Reflects the value defined in the openMSP430_defines.v file
• PER_SPACE : Peripheral address space for the current implementation
(byte size = PER_SPACE*512)
• MPY : This bit is set if the hardware multiplier is included in the 
current implementation.
• DMEM_SIZE : Data memory size for the current implementation
(byte size = DMEM_SIZE * 128)
• PMEM_SIZE : Program memory size for the current implementation
(byte size = PMEM_SIZE * 1024)
2.2.2 CPU_CTL
46This 8 bit read-write register is used to control the CPU and to configure some basic 
debug features. After a POR, this register is set to 0x10 or 0x30 (depending on the 
DBG_RST_BRK_EN  configuration option).
Register NameAddressBit Field
76543210
CPU_CTL0x02Res.CPU_RSTRST_BRK_ENFRZ_BRK_ENSW_BRK_ENISTEPRUNHALT
• CPU_RST : Setting this bit to 1 will activate the PUC reset. Setting it back to 
0 will release it.
• RST_BRK_EN : If set to 1, the CPU will automatically break after a PUC 
occurrence.
• FRZ_BRK_EN : If set to 1, the timers and watchdog are frozen when the CPU is 
halted.
• SW_BRK_EN : Enables the software breakpoint detection.
• ISTEP1: Writing 1 to this bit will perform a single instruction step if the 
CPU is halted.
• RUN1: Writing 1 to this bit will get the CPU out of halt state.
• HALT1: Writing 1 to this bit will put the CPU in halt state.
1:this field is write-only and always reads back 0. 
2.2.3 CPU_STAT
This 8 bit read-write register gives the global status of the debug interface. After a POR, 
this register is set to 0x00. 
Register NameAddressBit Field
76543210
CPU_STAT0x03HWBRK3_PNDHWBRK2_PNDHWBRK1_PNDHWBRK0_PNDSWBRK_PNDPUC_PNDRes.HALT_RUN
• HWBRK3_PND : This bit reflects if one of the Hardware Breakpoint Unit 3 status 
bit is set (i.e. BRK3_STAT≠0).
• HWBRK2_PND : This bit reflects if one of the Hardware Breakpoint Unit 2 status 
bit is set (i.e. BRK2_STAT≠0).
• HWBRK1_PND : This bit reflects if one of the Hardware Breakpoint Unit 1 status 
bit is set (i.e. BRK1_STAT≠0).
• HWBRK0_PND : This bit reflects if one of the Hardware Breakpoint Unit 0 status 
bit is set (i.e. BRK0_STAT≠0).
47• SWBRK_PND : This bit is set to 1 when a software breakpoint occurred. It can be 
cleared by writing 1 to it.
• PUC_PND : This bit is set to 1 when a PUC reset occurred. It can be cleared 
by writing 1 to it.
• HALT_RUN : This read-only bit gives the current status of the CPU: 
0 - CPU is running. 
1 - CPU is stopped. 
2.2.4 CPU_NR
This 16 bit read only register gives useful information for multi-core systems. 
Register NameAddressBit Field
1514131211109876543210
CPU_NR0x18CPU_TOTAL_NR CPU_INST_NR
• CPU_TOTAL_NR : Total number of oMSP instances – 1 (for multicore systems).
• CPU_INST_NR : Current oMSP instance number (for multicore systems).
2.3 Memory Access Registers
The following four registers enable single and burst read/write access to both CPU-
Registers and full memory address range. 
In order to perform an access, the following sequences are typically done: 
•single read access (MEM_CNT=0): 
1.set MEM_ADDR with the memory address (or register number) to be read
2.set MEM_CTL (in particular RD/WR=0 and START=1) 
3.read MEM_DATA 
•single write access (MEM_CNT=0): 
1.set MEM_ADDR with the memory address (or register number) to be 
written 
2.set MEM_DATA with the data to be written 
3.set MEM_CTL (in particular RD/WR=1 and START=1) 
•burst read/write access (MEM_CNT≠0): 
      ◦   burst access are optimized for the communication interface used (i.e. for 
the UART). The burst sequence are therefore described in the corresponding section ( 3.4 
Read/Write burst implementation for the CPU Memory access ) 
482.3.1 MEM_CTL
This 8 bit read-write register is used to control the Memory and CPU-Register read/write 
access. After a POR, this register is set to 0x00. 
Register Name AddressBit Field
76543210
MEM_CTL 0x04ReservedB/WMEM/REGRD/WRSTART
• B/W:0 - 16 bit access.
1 -   8 bit access (not valid for CPU-Registers).
• MEM/REG:0 - Memory access.
1 - CPU-Register access.
• RD/WR:0 - Read access.
1 - Write access.
• START:0- Do nothing
1 - Initiate memory transfer.
2.3.2 MEM_ADDR
This 16 bit read-write register specifies the Memory or CPU-Register address to be used 
for the next read/write transfer. After a POR, this register is set to 0x0000. 
Note: in case of burst (i.e. MEM_CNT≠0), this register specifies the first address of the 
burst transfer and will be incremented automatically as the burst goes (by 1 for 8-bit 
access and by 2 for 16-bit access). 
Register NameAddressBit Field
1514131211109876543210
MEM_ADDR 0x05 MEM_ADDR[15:0]
• MEM_ADDR: Memory or CPU-Register address to be used for the next 
read/write transfer.
2.3.3 MEM_DATA
This 16 bit read-write register gives (wr) or receive (rd) the Memory or CPU-Register 
data for the next transfer. After a POR, this register is set to 0x0000. 
49Register NameAddressBit Field
1514131211109876543210
MEM_DATA 0x06 MEM_DATA[15:0]
• MEM_DATA : if MEM_CTL.WR - data to be written during the next write 
transfer.
  if MEM_CTL.RD - updated with the data from the read transfer
2.3.4 MEM_CNT
This 16 bit read-write register controls the burst access to the Memory or CPU-Registers. 
If set to 0, a single access will occur, otherwise, a burst will be performed. The burst 
being optimized for the communication interface, more details are given there. After a 
POR, this register is set to 0x0000. 
Register NameAddressBit Field
1514131211109876543210
MEM_CNT0x07 MEM_CNT[15:0]
• MEM_CNT: =0 - a single access will be performed with the next transfer.
  ≠0 - specifies the burst size for the next transfer (i.e number of data 
access). This field will be automatically decremented as the burst goes.
2.4 Hardware Breakpoint Unit Registers
Depending on the defines located in the "openMSP430_defines.v " file, up to four 
hardware breakpoint units can be included in the design. These units can be individually 
controlled with the following registers. 
2.4.1 BRKx_CTL
This 8 bit read-write register controls the hardware breakpoint unit x. After a POR, this 
register is set to 0x00. 
Register Name AddressBit Field
76543210
BRKx_CTL0x08, 0x0C,
0x10, 0x14ReservedRANGE_MODEINST_ENBREAK_ENACCESS_MODE
• RANGE_MODE : 0 - Address match on BRK_ADDR0 or BRK_ADDR1 (normal
mode)
50  1 - Address match on BRK_ADDR0→BRK_ADDR1 range
(range mode)
Note: range mode is not supported by the core unless the 
`DBG_HWBRK_RANGE define is set to 1'b1 in the 
openMSP430_define.v  file.
• INST_EN : 0 - Checks are done on the execution unit (data flow).
  1 - Checks are done on the frontend (instruction flow).
• BREAK_EN : 0 - Watchpoint mode enable (don't stop on address match).
  1 - Breakpoint mode enable (stop on address match).
• ACCESS_MODE : 00 - Disabled
  01 - Detect read access. 
  10 - Detect write access. 
  11 - Detect read/write access 
Note: '10' & '11' modes are not supported on the instruction flow
2.4.2 BRKx_STAT
This 8 bit read-write register gives the status of the hardware breakpoint unit x. Each 
status bit can be cleared by writing 1 to it. After a POR, this register is set to 0x00. 
Register NameAddressBit Field
76543210
BRKx_STAT0x09, 0x0D,
0x11, 0x15ReservedRANGE_WRRANGE_RDADDR1_WRADDR1_RDADDR0_WRADDR0_RD
• RANGE_WR: This bit is set whenever the CPU performs a write access within the 
BRKx_ADDR0→BRKx_ADDR1 range (valid if RANGE_MODE=1 
and ACCESS_MODE[1]=1).
• RANGE_RD: This bit is set whenever the CPU performs a read access within the 
BRKx_ADDR0→BRKx_ADDR1 range (valid if RANGE_MODE=1 
and ACCESS_MODE[0]=1).
Note: range mode is not supported by the core unless the 
`DBG_HWBRK_RANGE define is set to 1'b1 in the 
openMSP430_define.v  file.
• ADDR1_WR: This bit is set whenever the CPU performs a write access at the 
BRKx_ADDR1 address (valid if RANGE_MODE=0 and 
51ACCESS_MODE[1]=1).
• ADDR1_RD: This bit is set whenever the CPU performs a read access at the 
BRKx_ADDR1 address (valid if RANGE_MODE=0 and 
ACCESS_MODE[0]=1).
• ADDR0_WR: This bit is set whenever the CPU performs a write access at the 
BRKx_ADDR0 address (valid if RANGE_MODE=0 and 
ACCESS_MODE[1]=1).
• ADDR0_RD: This bit is set whenever the CPU performs a read access at the 
BRKx_ADDR0 address (valid if RANGE_MODE=0 and 
ACCESS_MODE[0]=1).
2.4.3 BRKx_ADDR0
This 16 bit read-write register holds the value which is compared against the address 
value currently present on the program or data address bus. After a POR, this register is 
set to 0x0000. 
Register Name AddressBit Field
1514131211109876543210
BRKx_ADDR00x0A, 0x0E,
0x12, 0x16BRK_ADDR0[15:0]
• BRK_ADDR0: Value compared against the address value currently present on the 
program or data address bus.
2.4.4 BRKx_ADDR1
This 16 bit read-write register holds the value which is compared against the address 
value currently present on the program or data address bus. After a POR, this register is 
set to 0x0000. 
Register Name AddressesBit Field
1514131211109876543210
BRKx_ADDR10x0B, 0x0F,
0x13, 0x17BRK_ADDR1[15:0]
• BRK_ADDR1: Value compared against the address value currently present on the 
program or data address bus.
523. Debug Communication Interface: 
UART
With its UART interface, the openMSP430 debug unit can communicate with the host 
computer using a simple RS232 cable (connected to the dbg_uart_txd and dbg_uart_rxd 
ports of the IP).
Typically, a USB to RS232 or USB to serial TTL cable will provide a reliable 
communication link between your host PC and the openMSP430 (speed being typically 
limited by the cable length). 
3.1 Serial communication protocol: 8N1
There are plenty tutorials on Internet regarding RS232 based protocols. However, here is 
quick recap about 8N1 (1 Start bit, 8 Data bits, No Parity, 1 Stop bit):
As you can see in the above diagram, data transmission starts with a Start bit, followed by
the data bits (LSB sent first and MSB sent last), and ends with a "Stop" bit. 
3.2 Synchronization frame
After a POR, the Serial Debug Interface expects a synchronization frame from the host 
computer in order to determine the communication speed (i.e. the baud rate).
The synchronization frame looks as following: 
As you can see, the host simply sends the 0x80 value. The openMSP430 will then 
measure the time between the falling and rising edge, divide it by 8 and automatically 
deduce the baud rate it should use to properly communicate with the host. 
Important note: if you want to change the communication speed between two debugging
sessions, the Serial Debug Interface needs to go through a reset cycle (i.e. through the 
reset_n or dbg_en pins) and a new synchronization frame needs to be send.
53
3.3 Read/Write access to the debug registers
In order to perform a read / write access to a debug register, the host needs to send a 
command frame to the openMSP430.
In case of write access, this command frame will be followed by 1 or 2 data frames and in
case of read access, the openMSP430 will send 1 or 2 data frames after receiving the 
command. 
3.3.1 Command Frame
The command frame looks as following: 
• WR: Perform a Write access when set. Read otherwise.
• B/W: Perform a 8-bit data access when set (one data frame). 16-bit otherwise 
(two data frame).
• Address: Debug register address.
3.3.2 Write access
A write access transaction looks like this: 
3.3.3 Read access
A read access transaction looks like this: 
54
3.4 Read/Write burst implementation for the CPU
Memory access
In order to optimize the data burst transactions for the UART, read/write access are not 
done by reading or writing the MEM_DATA register.
Instead, the data transfer starts immediately after the MEM_CTL.START bit has been set.
3.4.1 Write Burst access
A write burst transaction looks like this: 
3.4.2 Read Burst access
A read burst transaction looks like this: 
55
4. Debug Communication Interface: I2C
With its I2C interface, the openMSP430 debug unit can communicate with the host 
computer using an I2C adapter (connected to the dbg_i2c_scl and 
dbg_i2c_sda_in/dbg_i2c_sda_out  ports of the IP).
Currently, the USB-ISS adapter from Devantech (Robot Electronics) is supported by the 
software development tools and provides a reliable communication link between your 
host PC and the openMSP430. 
4.1 I2C communication protocol
There are plenty tutorials on Internet regarding the I2C protocol (see the official I2C 
specification for more info).
A simple byte read or write frame looks as following:
4.2 Synchronization frame
Unlike the UART interface, the I2C is a synchronous communication protocol.
A synchronization frame is therefore not required.
4.3 Read/Write access to the debug registers
In order to perform a read / write access to a debug register, the host needs to send a 
command frame to the openMSP430.
In case of write access, this command frame will be followed by 1 or 2 data frames and in
case of read access, the openMSP430 will send 1 or 2 data frames after receiving the 
command. 
56
4.3.1 Command Frame
The command frame looks as following:
• WR: Perform a Write access when set. Read otherwise.
• B/W: Perform a 8-bit data access when set (one data frame). 16-bit otherwise 
(two data frame).
• Address: Debug register address.
4.3.2 Write access
A write access transaction looks like this: 
4.3.3 Read access
A read access transaction looks like this: 
57
4.4 Read/Write burst implementation for the CPU
Memory access
In order to optimize the data burst transactions for the I2C, read/write access are not done
by reading or writing the MEM_DATA register.
Instead, the data transfer starts immediately after the MEM_CTL.START bit has been set.
4.4.1 Write Burst access
A write burst transaction looks like this: 
4.4.2 Read Burst access
A read burst transaction looks like this: 
58
6.
Integration and
Connectivity
Table of content
•1. Overview 
•2. Clocks 
•3. Resets 
•4. Program Memory  
•5. Data Memory 
•6. Peripherals 
•7  .   Direct Memory Access Interface  
•8  . Interrupts 
•9  . Serial Debug Interfaces
•9  .1 UART Configuration
•9  .2 I2C Configuration
591. Overview
This chapter aims to give a comprehensive description of all openMSP430 core interfaces
in order to facilitate its integration within an ASIC or FPGA.
The following diagram shows an overview of the openMSP430 core connectivity in an 
FPGA system (i.e. all ASIC specific pins are left unused):
60
The full pinout of the core is summarized in the following table.
Port NameDirec-
tionWidth Clock
Domain Description
Clocks
cpu_en Input1<async>
or mclk4Enable CPU code execution 
(asynchronous and non-glitchy).
Set to 1 if unused.
dco_clk Input 1 -Fast oscillator (fast clock)
lfxt_clk Input 1 -Low frequency oscillator (typ. 32KHz)
Set to 0 if unused.
mclk Output 1 -Main system clock 
aclk_en Output 1 mclkFPGA ONLY: ACLK enable 
smclk_en Output 1 mclkFPGA ONLY: SMCLK enable 
dco_enable Output 1 dco_clkASIC ONLY: Fast oscillator enable
dco_wkup Output 1 <async>ASIC ONLY: Fast oscillator wakeup
(asynchronous)
lfxt_enable Output 1 lfxt_clkASIC ONLY: Low frequency oscillator 
enable 
lfxt_wkup Output 1 <async>ASIC ONLY: Low frequency oscillator 
wakeup (asynchronous)
aclk Output 1 -ASIC ONLY: ACLK
smclk Output 1 -ASIC ONLY: SMCLK
wkup Input 1 <async>ASIC ONLY: System Wake-up
(asynchronous and non-glitchy)
Set to 0 if unused.
Resets 
puc_rst Output 1 mclkMain system reset 
reset_n Input 1 <async>Reset Pin (active low, asynchronous and 
non-glitchy) 
61Program Memory interface  
pmem_addr Output `PMEM_
AWIDT
H1 mclkProgram Memory address 
pmem_cen Output 1 mclkProgram Memory chip enable (low 
active) 
pmem_din Output 16 mclkProgram Memory data input (optional2)
pmem_dout Input 16 mclkProgram Memory data output 
pmem_wen Output 2 mclkProgram Memory write byte enable (low
active) (optional2)
Data Memory interface  
dmem_addr Output `DMEM
_
AWIDT
H1 mclkData Memory address 
dmem_cen Output 1 mclkData Memory chip enable (low active) 
dmem_din Output 16 mclkData Memory data input 
dmem_dout Input 16 mclkData Memory data output 
dmem_wen Output 2 mclkData Memory write byte enable (low 
active) 
External Peripherals interface  
per_addr Output 14 mclkPeripheral address 
per_din Output 16 mclkPeripheral data input 
per_dout Input 16 mclkPeripheral data output 
per_en Output 1 mclkPeripheral enable (high active) 
per_we Output 2 mclkPeripheral write byte enable (high 
active) 
Direct Memory Access interface  
dma_addr Input15mclkDirect Memory Access address
dma_din Input16mclkDirect Memory Access data input
62dma_dout Output16mclkDirect Memory Access data output
dma_en Input1mclkDirect Memory Access enable (high 
active)
dma_priority Input1mclkDirect Memory Access (0:low / 1:high)
dma_ready Output1mclkDirect Memory Access is complete
dma_resp Output1mclkDirect Memory Access (0:Okay / 
1:Error)
dma_we Input2mclkDirect Memory Access write byte enable
(high active)
dma_wkup Input1<async>ASIC ONLY: DMA Wake-up 
(asynchronous and non-glitchy)
Interrupts 
irq Input `IRQ_N
R-21 mclkMaskable interrupts (one-hot signal) 
nmi Input 1 <async>
or mclk4Non-maskable interrupt (asynchronous) 
irq_acc Output `IRQ_N
R-21 mclkInterrupt request accepted (one-hot 
signal) 
Serial Debug interface  
dbg_en Input1<async>
or mclk4Debug interface enable (asynchronous)3
dbg_freeze Output 1 mclkFreeze peripherals 
dbg_uart_txd Output 1 mclkDebug interface: UART TXD 
dbg_uart_rxd Input 1 <async>Debug interface: UART RXD 
(asynchronous)
dbg_i2c_addr Input7mclkDebug interface: I2C Address
dbg_i2c_broadcast Input7mclkDebug interface: I2C Broadcast Address 
(for multicore only)
dbg_i2c_scl Input1<async>Debug interface: I2C SCL
dbg_i2c_sda_in Input1<async>Debug interface: I2C SDA input
63dbg_i2c_sda_out Output1mclkDebug interface: I2C SDA output
Scan
scan_enable Input1dco_clkASIC ONLY: Scyn enable (active during
scan shifting)
scan_mode Input1<stable>ASIC ONLY: Scan mode
1: This parameter is declared in the openMSP430_defines.v  file and defines the 
RAM/ROM size or the number of interrupts vectors (16, 32 or 64).
2: These two optional ports can be connected whenever the program memory is a RAM. 
This will allow the user to load a program through the serial debug interface and to use 
software breakpoints.
3: When disabled, the debug interface is hold into reset (and clock gated in ASIC mode). 
As a consequence, the dbg_en port can be used to reset the debug interface without 
disrupting the CPU execution.
4: Clock domain is selectable through configuration in the openMSP430_defines.v  file 
(see Advanced System Configuration).
2. Clocks
The different clocks in the design are managed by the Basic Clock Module as following 
in the FPGA configuration:
64
 or as following in the ASIC configuration:
•CPU_EN: this input port provides a hardware mean to stop or resume CPU 
execution. When unused, this port should be set to 1.
•DCO_CLK: this input port is typically connected to a PLL, RC oscillator or any 
clock resource the target FPGA/ASIC might provide.
From a synthesis tool perspective (ISE, Quartus, Libero, Design Compiler...), this 
the only port where a clock needs to be declared. 
•LFXT_CLK: in an FPGA system, if ACLK_EN or SMCLK_EN are going to be 
used in the project (for example through the Watchdog or TimerA peripherals), 
then this port needs to be connected to a clock running at least two time slower as 
DCO_CLK (typically 32kHz). It can be connected to 0 or 1 otherwise. 
In an ASIC, if ACLK or SMCLK are used and if the clock muxes are included, 
then this port can be connected to any kind of clock source (it doesn't need to be 
low-frequency. The name was just kept to be consistent with TI's documentation).
•MCLK: the main system clock drives the complete openMSP430 clock domain, 
including program/data memories and the peripheral interfaces. 
65
•ACLK_EN / SMCLK_EN : these two clock enable signals can be used in order to
emulate the original ACLK and SMCLK from the MSP430 specification when the
core is targeting an FPGA.
An example of this can be found in the Watchdog and TimerA modules, where it 
is implemented as following:
 
•ACLK / SMCLK: ACLK and MCLK are available through these two ports when
targeting an ASIC.
• DCO_ENABLE / DCO_WKUP : ASIC specific signals controlling the fast 
clock generator for low power mode support (SCG0 bit in the status register).
•LFXT_ENABLE / LFXT_WKUP : ASIC specific signals controlling the low 
frequency clock generator for low power mode support (OSCOFF bit in the status 
register).
•WKUP: When activated, this signal allows a peripheral to restore all CPU clocks 
(i.e. wakeup the cpu) prior IRQ generation. Note that IRQs MUST always be 
generated from the MCLK clock domain.
As an FPGA system illustration, the following waveform shows the different clocks 
where the software running on the openMSP430 configures the BCSCTL1 and 
BCSCTL2 registers so that ACLK_EN and SMCLK_EN are respectively running at 
LFXT_CLK/2 and DCO_CLK/4.
 
66
3. Resets
•RESET_N: this input port is typically connected to a board push button and is 
generally combined with the system power-on-reset. 
•PUC_RST: the Power-Up-Clear signal is asynchronously set with the reset pin 
(RESET_N), the watchdog reset or the serial debug interface reset. In order to get 
clean timings, it is synchronously cleared with MCLK. As a general rule, this 
signal should be used as the reset of the MCLK clock domain. 
The following waveform illustrates this:
4. Program Memory
Depending on the project needs, the program memory can be either implemented as a 
ROM or RAM.
If a ROM is selected then the PMEM_DIN and PMEM_WEN ports won't be connected. 
In that case, the software debug capabilities are limited because the serial debug interface 
can only use hardware breakpoints in order to stop the program execution. In addition, 
updating the software will require a reprogramming of the FPGA... or a new ROM mask 
for an ASIC.
If the program memory is a RAM, the developer gets full flexibility regarding software 
debugging. The serial debug interface can be used to update the program memory and 
software breakpoints can be used.
67
That said, the protocol between the openMSP430 and the program memory is quite 
standard. Signal description goes as following: 
•PMEM_CEN: when this signal is active, the read/write access will be executed 
with the next MCLK rising edge. Note that this signal is LOW ACTIVE. 
•PMEM_ADDR: Memory address of the 16 bit word which is going to be 
accessed.
Note: in order to calculate the core logical address from the program memory 
physical address, the formula goes as following: 
LOGICAL@=2*PHYSICAL@+0x10000-PMEM_SIZE  
•PMEM_DOUT: the memory output word will be updated with every valid 
read/write access (i.e. PMEM_DOUT is not updated if PMEM_CEN=1). 
•PMEM_WEN: this signal selects which byte should be written during a valid 
access. PMEM_WEN[0] will activate a write on the lower byte, PMEM_WEN[1] 
a write on the upper byte. Note that these signals are LOW ACTIVE. 
•PMEM_DIN: the memory input word will be written with the valid write access 
according to the PMEM_WEN value. 
The following waveform illustrates some read accesses of the program memory (write 
access are illustrated in the data memory section):
68
5. Data Memory
The data memory is always implemented as a RAM.
The protocol between the openMSP430 and the data memory is the same as the one of 
the program memory. Therefore, the signal description is the same: 
•DMEM_CEN: when this signal is active, the read/write access will be executed 
with the next MCLK rising edge. Note that this signal is LOW ACTIVE. 
•DMEM_ADDR: Memory address of the 16 bit word which is going to be 
accessed.
Note: in order to calculate the core logical address from the data memory physical
address, the formula goes as following: LOGICAL@=2*PHYSICAL@+0x200  
•DMEM_DOUT: the memory output word will be updated with every valid 
read/write access (i.e. DMEM_DOUT is not updated if DMEM_CEN=1). 
•DMEM_WEN: this signal selects which byte should be written during a valid 
access. DMEM_WEN[0] will activate a write on the lower byte, DMEM_WEN[1]
a write on the upper byte. Note that these signals are LOW ACTIVE. 
•DMEM_DIN: the memory input word will be written with the valid write access 
according to the DMEM_WEN value. 
The following waveform illustrates some read/write access to the data memory:
 
69
6. Peripherals
The protocol between the openMSP430 core and its peripherals is the exactly same as the
one with the data and program memories in regard to write access and differs slightly for 
read access.
On the connectivity side, the specificity is that the read data bus of all peripherals should 
be ORed together before being connected to the core, as showed in the diagram of the 
Overview section.
From the logical point of view, during a read access, each peripheral outputs the 
combinatorial value of its read mux and returns 0 if it doesn't contain the addressed 
register. On the waveforms, this translates by seeing the register value on PER_DOUT 
while PER_EN is valid and not one clock cycle afterward as it is the case with the 
program and data memories.
In any case, it is recommended to use the templates provided with the core in order to 
develop your own custom peripherals.
The signal description therefore goes as following: 
•PER_EN: when this signal is active, read access are executed during the current 
MCLK cycle while write access will be executed with the next MCLK rising edge. 
Note that this signal is HIGH ACTIVE. 
•PER_ADDR: peripheral register address of the 16 bit word which is going to be 
accessed. It is to be noted that a 14 bit address will always be provided from the 
openMSP430 to the peripheral in order to accommodate the biggest possible 
PER_SIZE Verilog configuration option (i.e. 32kB as opposed to 512B by 
default).
Note: in order to calculate the core logical address from the peripheral register 
physical address, the formula goes as following: LOGICAL@=2*PHYSICAL@  
•PER_DOUT: the peripheral output word will be updated with every valid 
read/write access, it will be set to 0 otherwise. 
•PER_WE: this signal selects which byte should be written during a valid access. 
PER_WE[0] will activate a write on the lower byte, PER_WE[1] a write on the 
upper byte. Note that these signals are HIGH ACTIVE. 
•PER_DIN: the peripheral input word will be written with the valid write access 
according to the PER_WE value.
70The following waveform illustrates some read/write access to the peripheral registers:
7. Direct Memory Access Interface
Before moving on, please note that further details about the DMA interface can be found
in its dedicated section.
The protocol between the DMA interface master (DMA controller, bootloader, ...) and the
openMSP430 core is similar to the one followed between the openMSP430 and its data
memory. 
However, it comes with a few additional features to support wait states, error response,
priority and wakeup (for LPMx modes).
The signal description goes as following:
•DMA_EN: this signal enables a DMA transfer and can be released once the
transfer is completed, as signaled by DMA_READY .  
•DMA_ADDR: Logical address of the 16bit word currently accessed by the
interface. The address must stay valid until the transfer is completed, as signaled
by DMA_READY .
Note: the integrated oMSP memory backbone module decode the
specified logical DMA address and maps it accordingly to the  physical address of
the Program, Data or Peripheral memory.  
•DMA_DOUT: When performing a read acces, the DMA data output is valid
during the MCLK cycle immediately following the end of the transfer, as signaled
by DMA_READY .  
71
•DMA_WE: This signal, asserted together with DMA_EN, allows to selects which
byte should be written during the transfer. DMA_WE[0] activates a write on the
lower byte, DMA_WE[1] a write on the upper byte.
•DMA_DIN: When performing a write access, the DMA data input must stay valid
until the transfer is completed, as signaled by DMA ready.  
•DMA_PRIORITY : When SET, the oMSP memory backbone gives highest
priority to the DMA transfer and stops CPU execution.  
When CLEARED, the oMSP memory backbone gives highest priority to CPU
execution and the DMA transfer is completed only when the CPU doesn't access
the targeted ressource (pmem, dmem or peripheral).  
Note: a DMA controller can control the DMA data rate without stalling the CPU
by dynamically asserting/deasserting the DMA_PRIORITY port between
transfers. 
•DMA_READY: This port signals that the current DMA transfer is completed.  
Note: DMA_READY is typically hold low when the CPU owns the interface of
the target ressource.  
•DMA_RESP: This port signals if the current transfer was successful (0) or if an
error occured (1) and is valid together with DMA_READY .
Note: an error is typically signaled when an access is performed outside of any
memory mapped area (for example between Program and Data memory).  
•DMA_WKUP: For ASIC implementations supporting the Low-Power-Modes,
this port is used to asynchronously restore the clocks before performing a DMA
transfer. 
Note: it is possible to control which clocks are restored during a DMA wakeup
using the BCSCTL1 register of the Basic Clock Module. 
The following waveform illustrates some read/write access using the DMA interface:
72
8. Interrupts
As with the original MSP430, the interrupt priorities of the openMSP430 are fixed in 
hardware accordingly to the connectivity of the NMI and IRQ ports.
If two interrupts are pending simultaneously, the higher priority interrupt will be serviced 
first.
The following table summarize this:
  Interrupt Port    Vector address    Priority  
RESET_N 0xFFFE15 (highest)
NMI0xFFFC 14
IRQ[13] 0xFFFA 13
IRQ[12] 0xFFF8 12
IRQ[11] 0xFFF6 11
IRQ[10] 0xFFF4 10
IRQ[9] 0xFFF2 9
IRQ[8] 0xFFF0 8
IRQ[7] 0xFFEE 7
IRQ[6] 0xFFEC 6
IRQ[5] 0xFFEA 5
IRQ[4] 0xFFE8 4
IRQ[3] 0xFFE6 3
IRQ[2] 0xFFE4 2
IRQ[1] 0xFFE2 1
IRQ[0] 0xFFE00 (lowest)
The signal description goes as following: 
•NMI: The Non-Maskable Interrupt has higher priority than other IRQs and is 
masked by the NMIIE bit instead of GIE.
It is internally synchronized to the MCLK domain and can therefore be connected 
to any asynchronous signal of the chip (which could for example be a pin of the 
FPGA). If unused, this signal should be connected to 0. 
•IRQ: The standard interrupts can be connected to any signal coming from the 
MCLK domain (typically a peripheral). Priorities can be chosen by selecting the 
proper bit of the IRQ bus as shown in the table above. Unused interrupts should be
73connected to 0.
Note: IRQ[10] is internally connected to the Watchdog interrupt. If this bit is also 
used by an external peripheral, they will both share the same interrupt vector. 
•IRQ_ACC: Whenever an interrupt request is serviced, some peripheral 
automatically clear their pending flag in hardware. In order to do so, the 
IRQ_ACC bus can be used by using the bit matching the corresponding IRQ bit. 
An example of this is shown in the implementation of the TACCR0 Timer A 
interrupt. 
The following waveform illustrates a TAIV interrupt issued by the Timer-A, which is
connected to IRQ[8]:
74
9. Serial Debug Interface
The serial debug interface module provides a two-wires communication bus for remote 
debugging and an additional freeze signal which might be useful for some peripherals 
(typically timers).
•DBG_EN: this signal allows the user to enable or disable the serial debug 
interface without interfering with the CPU execution. It is to be noted that when 
disabled (i.e. DBG_EN=0), the debug interface is held into reset.
•DBG_FREEZE: this signal will be set whenever the debug interface stops the 
CPU (and if the FRZ_BRK_EN field of the CPU_CTL debug register is set). As its
name implies, the purpose of DBG_FREEZE is to freeze a peripheral whenever 
the CPU is stopped by the software debugger.
For example, it is used by the Watchdog timer in order to stop its free-running 
counter. This prevents the CPU from being reseted by the watchdog every times 
the user stops the CPU during a debugging session.
9.1 UART Configuration
•DBG_UART_TXD  / DBG_UART_RXD : these signals are typically connected 
to an RS-232 transceiver and will allow a PC to communicate with the 
openMSP430 core. 
The following waveform shows some communication traffic on the serial bus :
 
75
9.2 I2C Configuration
•DBG_I2C_ADDR : I2C Device address of the oMSP core (between 8 and 119). In
a multi-core configuration, each core has its own address. 
•DBG_I2C_BROADCAST : I2C Device broadcast address of the oMSP core 
(between 8 and 119). In a multi-core configuration, all cores have the same 
broadcast address. 
•DBG_I2C_SCL: I2C bus clock input (SCL). 
•DBG_I2C_SDA_OUT  / DBG_I2C_SDA_IN : these signals are connected to the 
SDA I/O cell as following:
The following waveform shows some communication traffic on the I2C bus:
76
7.
ASIC Implementation
Table of content
•1. Introduction
•2. RTL Configuration
•2.1 Basic Clock Module
•2.1.1 Low-frequency clock domain
•2.1.2 Clock muxes
•2.1.3 Clock dividers
•2.1.4 Low-Power modes
•2.1.4.1 Internal clocks ( MCLK / SMCLK )
•2.1.4.2 Clock oscillators ( DCO_CLK / LFXT_CLK )
•2.2 Other configuration options
•2.2.1 Fine grained clock gating
•2.2.2 Watchdog clock mux
•3. DFT considerations
•3.1 Resets
•3.2 Clock Gates
•3.3 Clock Muxes
•3.4 Coverage
•4. Sensitive modules
•4.1 AND Gate ( omsp_and_gate.v )
•4.2 Clock Gate ( omsp_clock_gate.v )
•4.3 Clock Mux ( omsp_clock_mux.v )
•4.4 Scan Mux ( omsp_scan_mux.v )
•4.5 Sync Cell ( omsp_sync_cell.v )
•4.6 Sync Reset ( omsp_sync_reset.v )
•4.7 Wakeup Cell ( omsp_wakeup_cell.v )
771. Introduction
This section covers specific points of the openMSP430 ASIC implementation, in 
particular:
•The ASIC specific RTL configuration options.
•Some DFT considerations.
•A description of each ASIC sensitive module.
Keep in mind that as no exotic design technique were used in the openMSP430, 
following a standard implementation flow from Synthesis to P&R is the best way to go.
2. RTL Configuration
Whenever the "`define ASIC" statement of the Expert System Configuration  section is 
uncommented, all ASIC specific configuration options are enabled.
2.1 Basic Clock Module
In its ASIC configuration, the Basic clock module of the openMSP430 can support up to 
all features described in the MSP430x1xx Family User's Guide  (Chapter 4).
In particular, the ASIC_CLOCKING  option activates all advancd clocking options (note 
that formal equivalence with the FPGA version is achieved by commenting this option 
out):
//===============================================================// ASIC CLOCKING
//===============================================================
//-------------------------------------------------------// When uncommented, this define will enable the ASIC// architectural clock gating as well as the advanced low// power modes support (most common).// Comment this out in order to get FPGA-like clocking.//-------------------------------------------------------`define ASIC_CLOCKING
78All these advanced clocking options are highlighted in the following diagram and 
discussed below:
2.1.1 Low-Frequency Clock Domain
The LFXT clock domain can be enabled thanks to the following configuration option:
//============================================================================
// LFXT CLOCK DOMAIN//============================================================================
//-------------------------------------------------------------
// When uncommented, this define will enable the lfxt_clk// clock domain.// When commented out, the whole chip is clocked with dco_clk.//-------------------------------------------------------------`define LFXT_DOMAIN
Note 1: When commented-out:
•ACLK is running on DCO_CLK
•MCLK_MUX and SMCLK_MUX options are not supported
•OSCOFF_EN low power mode is not supported
Note 2: Unlike its name suggest, there is no frequency limitation on LFXT_CLK. The 
name was simply kept in order to be consistent with the original MSP430 documentation,
where LFXT_CLK is typically connected to a 32 kHz crystal oscillator.
79
2.1.2 Clock Muxes
The MCLK and SMCLK clock muxes can be enabled or disabled with the following 
options:
//============================================================================
// CLOCK MUXES//============================================================================
//-------------------------------------------------------
// MCLK: Clock Mux//-------------------------------------------------------// When uncommented, this define will enable the// MCLK clock MUX allowing the selection between
// DCO_CLK and LFXT_CLK with the BCSCTL2.SELMx register.// When commented, DCO_CLK is selected.
//-------------------------------------------------------`define MCLK_MUX
//-------------------------------------------------------
// SMCLK: Clock Mux//-------------------------------------------------------
// When uncommented, this define will enable the// SMCLK clock MUX allowing the selection between// DCO_CLK and LFXT_CLK with the BCSCTL2.SELS register.// When commented, DCO_CLK is selected.
//-------------------------------------------------------`define SMCLK_MUX
Note 1: When a MUX is excluded, the concerned clock ( MCLK and/or SMCLK) is 
running with DCO_CLK.
Note 2: If a MUX is included, the implementation and sign-off tools (in particular CTS 
and STA) must be aware that a new clock needs to be defined on the MUX output.
2.1.3 Clock Dividers
The MCLK, SMCLK and ACLK clock dividers can be enabled or disabled with the 
following options:
//============================================================================// CLOCK DIVIDERS
//============================================================================
//-------------------------------------------------------// MCLK: Clock divider//-------------------------------------------------------// When uncommented, this define will enable the
// MCLK clock divider (/1/2/4/8)//-------------------------------------------------------`define MCLK_DIVIDER
//-------------------------------------------------------// SMCLK: Clock divider (/1/2/4/8)//-------------------------------------------------------// When uncommented, this define will enable the
// SMCLK clock divider//-------------------------------------------------------`define SMCLK_DIVIDER
80//-------------------------------------------------------// ACLK: Clock divider (/1/2/4/8)//-------------------------------------------------------
// When uncommented, this define will enable the// ACLK clock divider
//-------------------------------------------------------`define ACLK_DIVIDER
The clock dividers instantiate a clock gate on the clock tree and are implemented as 
following:
2.1.4 Low-Power Modes
2.1.4.1 Internal clocks ( MCLK / SMCLK )
Two bit fields in the status register (R2) allow to control the system clocks:
•CPUOFF allows to switch-off MCLK
•SCG1 allows to switch-off SMCLK
These control bits are supported by the openMSP430 and can be included in the design 
with the following defines:
//============================================================================// LOW POWER MODES//============================================================================//-------------------------------------------------------// LOW POWER MODE: CPUOFF//-------------------------------------------------------
// When uncommented, this define will include the// clock gate allowing to switch off MCLK in// all low power modes: LPM0, LPM1, LPM2, LPM3, LPM4//-------------------------------------------------------`define CPUOFF_EN
//-------------------------------------------------------// LOW POWER MODE: SCG1//-------------------------------------------------------// When uncommented, this define will include the
// clock gate allowing to switch off SMCLK in// the following low power modes: LPM2, LPM3, LPM4
//-------------------------------------------------------`define SCG1_EN
81In order to keep the clock tree as flat as possible, the CPUOFF and SCG1 low power 
options share the same clock gate with the clock divider:
2.1.4.2 Clock oscillators ( DCO_CLK / LFXT_CLK )
There are two bit fields in the status register (R2) allowing to control the clock 
oscillators:
•SCG0 allows to switch-off the DCO oscillator
•OSCOFF allows to switch-off the LFXT oscillator
These control bits are supported by the openMSP430 and can be included in the design 
with the following defines:
//============================================================================// LOW POWER MODES//============================================================================
//-------------------------------------------------------// LOW POWER MODE: SCG0//-------------------------------------------------------
// When uncommented, this define will enable the// DCO_ENABLE/WKUP port control (always 1 when commented).
// This allows to switch off the DCO oscillator in the// following low power modes: LPM1, LPM3, LPM4//-------------------------------------------------------`define SCG0_EN
//-------------------------------------------------------// LOW POWER MODE: OSCOFF//-------------------------------------------------------// When uncommented, this define will include the// LFXT_CLK clock gate and enable the LFXT_ENABLE/WKUP// port control (always 1 when commented).// This allows to switch off the low frequency oscillator// in the following low power modes: LPM4//-------------------------------------------------------
`define OSCOFF_EN
The control logic of both DCO and LFXT oscillators is identical.
82When disabled, the *_WKUP signal is used to asynchronously wake up the oscillator.  
Once the oscillator is awake (and therefore a clock is available), the *_ENABLE signal 
will take over and synchronously keep the oscillator enabled until the CPU clears the 
SCG0 or OSCOFF bit again.
The following two waveforms illustrate the CPU entering the LPM1 mode, and in 
particular the DCO oscillator being switched-off:
•Entering LPM1 through a BIS #N, R2 instruction:
•Entering LPM1 through a RETI instruction:
Note: the DCO oscillator is enabled until the BIS and RETI instruction are fully executed
(i.e. until the CPU state machines reach their IDLE state).
83At last, this waveform shows the CPU going out of LPM1 mode and in particular the 
DCO oscillator wake-up sequence:
In order to wake-up the CPU from ANY low power mode, the system MUST ALWAYS 
go through the following chain of events (as illustrated in the previous waveform):
1.The peripheral (for example a timer) asserts the WKUP input of the
openMSP430 in order to asynchronously restore the clocks. At this 
stage, DCO_WKUP is activated and DCO_ENABLE is still 
cleared.
2.Once MCLK is available, the peripheral generates a synchronous 
IRQ signal in order to re-activate the CPU state machines.
3.The CPU state machines activated, DCO_ENABLE is 
synchronously set.
4.When the global interrupt enable flag (GIE) is cleared, 
DCO_WKUP is released two clock cycles later (i.e. same behavior 
as a reset synchronizer).
Important note: the peripheral should release the WKUP input 
when its interrupt pending flag is cleared. Otherwise the 
DCO_WKUP signal will be set again as soon as the GIE flag is 
restored by the RETI instruction... which is probably not the 
intended behavior :-P
5.The DCO oscillator is now enabled until SCG0 is set again.
842.2 Other configuration options
2.2.1 Fine Grained Clock Gating
Nowadays, all synthesis tools support automatic (fine grained) clock gating insertion.
However, as some design houses still prefer to have the clock gates directly instantiated 
in the RTL, there is the possibility to include the 'manual' fine grained clock gates in the 
design with the following define:
//============================================================================
// FINE GRAINED CLOCK GATING//============================================================================
//-------------------------------------------------------
// When uncommented, this define will enable the fine// grained clock gating of all registers in the core.
//-------------------------------------------------------`define CLOCK_GATING
2.2.2 Watchdog Clock Mux
The watchdog clock mux allows to select between ACLK and SMCLK. It can be enabled 
or disabled with the WATCHDOG_MUX define.
When excluded, the additional WATCHDOG_NOMUX_ACLK  option allows the user 
to decide if the watchdog clock should be hard-wired to ACLK (if uncommented) or 
SMCLK (if commented-out)
//============================================================================// CLOCK MUXES
//============================================================================
//-------------------------------------------------------// WATCHDOG: Clock Mux
//-------------------------------------------------------// When uncommented, this define will enable the
// Watchdog clock MUX allowing the selection between// ACLK and SMCLK with the WDTCTL.WDTSSEL register.// When commented out, ACLK is selected if the// WATCHDOG_NOMUX_ACLK define is uncommented, SMCLK is
// selected otherwise.//-------------------------------------------------------`define WATCHDOG_MUX//`define WATCHDOG_NOMUX_ACLK
853. DFT Considerations
The openMSP430 is designed to be fully scan friendly. During production, the ATE 
controls the core through the scan_mode and scan_enable signals. The scan_mode port 
is always asserted during scan testing and is used to switch between functional and scan 
mode.
3.1 Resets
When in scan mode (i.e. scan_mode input port is set), ALL internal resets of the 
openMSP430 are connected the reset_n input port.
Taking the POR generation as an example, it is implemented using the omsp_scan_mux 
module as following:
3.2 Clock Gates
When in scan mode (i.e. scan_mode input port is set), ALL clock gates instantiated in the
design must be enabled during scan shifting. This is can be achieved by setting the 
scan_enable input port during the shift phase.
On the other hand, during the capture phase, the scan_enable port must be cleared in 
order to restore the functional behavior of the clock gate.
This feature is implemented in the omsp_clock_gate module as following:
863.3 Clock Muxes
When in scan mode (i.e. scan_mode input port is set), the MCLK and SMCLK clock 
muxes are both running on DCO_CLK. The watchdog mux is running SMCLK (i.e. 
DCO_CLK).
This feature is implemented in the omsp_clock_mux module as following:
Note: if the LFXT clock domain is enabled, the LFXT_CLK input port should also be 
connected to the scan clock when in scan mode.
3.4 Coverage
After synthesizing the openMSP430 in its maximum configuration (in particular with 
ALL clock domains available and ALL clock muxes included), the core reaches 99.7% 
stuck-at fault coverage:
874. Sensitive Modules
ALL modules discussed in this section have a simple and well defined functionality but 
nonetheless lay on sensitive parts of the design (clock tree, wake-up path, ...).
In the industry, it is common place for companies to have policies recommending 
designers to use textbook structures or specific standard cells when implementing circuits
considered as 'sensitive'.
This section will hopefully help to quickly identify these 'sensitive' circuits and adapt 
them to your requirements if necessary.
4.1 AND Gate ( omsp_and_gate.v )
This module implements a simple AND2 gate and is instantiated several times on the 
wake-up paths in order to ensure a glitch free generation of the wake-up signals. The idea
behind this block is to prevent the synthesis tool from optimizing the combinatorial wake-
up path and potentially generate a glitchy logic.
There are three different ways to handle this block:
1.Do nothing
2.Modify the RTL by directly instantiating an AND2 cell from the target library and 
applying a don't touch or size only attribute on it before proceeding to the 
synthesis compile step
3.Keep the RTL unchanged and when running synthesis, first compile this module 
separately before going to the top down compile (don't forget the don't touch or 
size only attribute)
Note that the first option is actually acceptable because in low power mode, there are no 
clocks available, which means no glitch... However, in active mode, the wake-up line 
could see a lot of glitches, which is functionally not a problem (since the core is awake 
anyway) but could be considered as not really elegant...
884.2 Clock Gate ( omsp_clock_gate.v )
Almost every company has a different policy for handling clock gates. Therefore, this 
module is probably the most likely to be modified.
So here are the facts:
•There are only rising edge flip-flop in the design1
→ as a consequence clock gates can indifferently park the clock high or low 
without affecting functionality.
•The enable signal of ALL clock gates in the openMSP430 are generated with the 
rising edge of the clock
→ this leaves the door open for both LATCH and NAND2 based clock gates.
1: beside for the DCO_ENABLE and LFXT_ENABLE signals and the clock MUXes. However, these can be 
safely ignored
As a consequence, you can feel free to use:
•A LATCH based clock gate. For example:
•Or a NAND2 based clock gate:
894.3 Clock Mux ( omsp_clock_mux.v )
The clock muxes of the openMSP430 are implemented as following:
In order to make this implementation 100% bullet proof, the RTL could be modified by 
manually instantiating the NAND2 and AND2 cells directly from the target library (with 
the associated don't touch or size only attributes of course).
However, if you decide to compile this module as it is, the synthesis tool should normally
be smart enough and not mess it up (but PLEASE PLEASE PLEASE double check 
manually the resulting gate netlist).
904.4 Scan Mux ( omsp_scan_mux.v )
As illustrated in the section 3.1, the scan mux cell allows ALL internal resets to be 
controllable with the reset_n input port in scan mode.
In addition, the scan mux is also used by the omsp_wakeup_cell (see section 4.7 below).
4.5 Sync Cell ( omsp_sync_cell.v )
The following synchronization cell is instantiated on all clock domain crossing data 
paths:
4.6 Sync Reset ( omsp_sync_reset.v )
Internal resets are generated using the following standard reset synchronizer:
914.7 Wakeup Cell ( omsp_wakeup_cell.v )
The wakeup cell is the most unconventional module of the openMSP430 design as it 
contains a flip-flop whose clock and reset are both coming from a data path.
In the openMSP430 core, it is instantiated a single time in the watchdog timer but can 
also be reused in external custom peripherals.
The implementation of the block looks as following:
The basic idea here is simply to set the WKUP_OUT signal with a rising edge on the 
WKUP_EVENT port, and clear it when WKUP_CLEAR is active (i.e. level sensitive 
clear).
92In order to give a better perspective from a system point of view, the following diagram 
shows how the wakeup cell has been used in the particular case of the watchdog timer 
(note that WDTIFG_CLR_REG and WDTQN_EDGE_REG are both output of a flip-flop
and therefore glitch-free):
Note: Wake-up signals can of course be generated in a different way as long as they 
directly come from a flip-flop (or are certified to be non-glitchy).
For example a simple handshake between the WDT_CLK and MCLK clock domains 
could have been used to clear the WDT_WKUP signal in a fully synchronous manner.
However, it is to be noted that this handshake would introduce some synchronization 
delay, which might not be negligible if MCLK and WDT_CLK frequencies are orders of 
magnitude apart (i.e. several MHz for MCLK and 32kHz for WDT_CLK).
As getting the oscillators back to sleep as fast as possible might prove to be extremely 
important for low-power designs, this asynchronous solution was selected for the 
omsp_watchdog implementation.
938.
Area and Speed Analysis
Table of content
•1. Overview 
•1.1 FPGAs 
•1.2 ASICs 
•2. Detailed results 
Warning: the results presented here might vary depending on the tool versions, applied 
timing constraints and exact configuration of the openMSP430 core.
The FPGA results were obtained using the free tool versions provided by the vendors (i.e 
ISE 11.1, QuartusII 9.1 & Libero 8.5).
The ASIC synthesis was run with Synopsys Design Compiler 2007.12 ( without dc_ultra
or any special feature ). 
941. Overview
1.1 FPGAs
Utilization
Manu-
facturerDevices InfoBasic Config.
(Core +
Watchdog)Hardware
MultiplierWith debug
interface
(Software
breakpoints)Additional
Hardware
breakpoint
unit
XilinxSpartan 3
Spartan 3E
Spartan 3A
Spartan 3A
DSP
Virtex 44-inputs
LUTs1 620 + 200 + 520 + 80
Spartan 6
Virtex 5
Virtex 66-inputs
LUTs1 240 + 150 + 350 + 70
AlteraCyclone II
Cyclone III
Cyclone IV GX
StratixLEs 1 550 + 210 + 480 + 110
Arria GX
Arria II GX
Stratix II
Stratix IIIALUTs 1 030 + 115 + 380 + 90
ActelProASIC3E
ProASIC3L
ProASIC3
Fusion
IGLOOeTiles 3 550 + 1 060 + 1 200 + 220
- - Registers 470 + 75 + 140 + 45
95Speed
(in MHz, min and max values across all speed grades)
Manufacturer DevicesBasic Configuration
(Core + Watchdog + HW
Multiplier)With debug
interface
XilinxSpartan 3
Spartan 3E
Spartan 3A
Spartan 3A
DSP30 - 40 25 - 35
Spartan 6 40 - 65 35 - 60
Virtex 4 50 - 70 45 - 60
Virtex 5 75 - 100 65 - 85
Virtex 6 90 - 115 75 - 100
AlteraCyclone II 35 - 45 30 - 45
Cyclone III
Cyclone IV GX40 - 55 35 - 50
Arria II GX 65 - 85 60 - 80
Stratix II 55 - 75 50 - 65
Stratix III 75 - 95 70 - 90
ActelProASIC3E
ProASIC3L
ProASIC3
Fusion
IGLOOe15 - 25 15 - 25
961.2 ASICs
Area
ProcessTarget
FrequencyInfoBasic Config.
(Core +
Watchdog)Hardware
MultiplierWith debug
interface
(Software
breakpoints)Additional
Hardware
breakpoint
unit
180 nm50 MHz kGates 8 + 2.5 + 2 + 0.8
100 MHz kGates 10 + 4.4 + 2 + 1.2
2. Detailed results
Detailed results can be found in the PDF documentation (see the online download  
section).
979.
Software Development
Tools
Table of content
•1. Introduction 
•2. openmsp430-loader  
•3. openmsp430-minidebug  
•4. openmsp430-gdbproxy  
•5. MSPGCC Toolchain  
•5.1 Compiler options  
•5.2 MCU selection
•5.3 Custom linker script  
981. Introduction
Building on the serial debug interface capabilities provided by the openMSP430, three
utility programs are provided: 
•openmsp430-loader:  a simple command line boot loader. 
•openmsp430-minidebug:  a minimalistic debugger with simple GUI. 
•openmsp430-gdbproxy:  GDB Proxy server to be used together with MSP430-
GDB and the Eclipse, DDD, or Insight graphical front-ends. 
All these software development tools have been developed in TCL/TK and were
successfully tested on both Linux and Windows (XP/Vista/7). 
Note: to be able to execute the scripts, TCL/TK needs to be installed on your system.
In order to connect the host PC to the openMSP430 serial debug interface, a UART or
I2C serial cable/adapter is required.
Typically, the following solutions will suit any kind of development board:
UART I2C
USB to RS232 converter:
USB to Serial TTL converter:Devantech USB-ISS adapter:
99
2. openmsp430-loader
This simple program allows the user to load the openMSP430 program memory with an 
executable file (ELF or Intel-HEX format) provided as argument.
It is typically used in conjunction with ' make' in order to automatically load the program 
after the compile step (see ' Makefile' from software examples provided with the project's 
FPGA implementation).
The program can be called with the following syntax:
USAGE   : openmsp430-loader.tcl [-device    <communication port>]                                [-adaptor  <adaptor type>]                                [-speed    <communication speed>]                                [-i2c_addr <cpu address>]            <elf/ihex-file>
DEFAULT : <communication port>   = /dev/ttyUSB0          <adaptor type>        = uart_generic          <communication speed> = 115200 (for UART) / I2C_S_100KHZ (for I2C)          <core address>        = 42
EXAMPLES: openmsp430-loader.tcl -device /dev/ttyUSB0 -adaptor uart_generic -speed 9600   leds.elf
          openmsp430-loader.tcl -device COM2:         -adaptor i2c_usb-iss  -speed I2C_S_100KHZ                                -i2c_addr 75 ta_uart.ihex
These screenshots show the script in action under Linux and Windows:
100
3. openmsp430-minidebug
This small program provides a minimalistic graphical interface enabling simple 
interaction with the openMSP430: 
As you can see from the screenshot, it allows the following actions: 
•(1)  Connect to the openMSP430 Serial Debug Interface
•(2)  Load the program memory with an ELF or Intel-HEX file 
•(3)  Control the CPU: Reset, Stop, Start and Single-Step and Software breakpoints
•(4)  Read/Write access of the CPU registers 
•(5)  Read/Write access of the whole memory range (program, data, peripherals) 
•(6)  Basic disassembled view of the loaded program (current PC location is 
highlighted in green, software breakpoints in yellow, pink and violet)
•(7)  Choose the disassembled view type
•(8)  Source a custom external TCL script.
101
4. openmsp430-gdbproxy
The purpose of this program is to replace the ' msp430-gdbproxy' utility provided by the 
mspgcc toolchain.
Typically, a GDB proxy creates a local port for GDB to connect to, and handles the 
communication with the target hardware. In our case, it is basically a bridge between the 
RSP communication protocol from GDB and the serial debug interface from the 
openMSP430.
Schematically the communication flow looks as following: 
Like the original 'msp430-gdbproxy' program, 'openmsp430-gdbproxy ' can be controlled 
from the command line. However, it also provides a simple graphical interface: 
102
These two additional screenshots show the script in action together with the Eclipse and 
DDD graphical frontends:
103
Tip 1: There are several tutorials on Internet explaining how to configure Eclipse for the 
MSP430. As an Eclipse newbie, I found the followings quite helpful (the msp430-
gdbproxy sections should of course be ignored as we are using our own o penmsp430-
gdbproxy program :-) ):
•A Step By Step Guide To MSP430 Programming Under Linux  (English) 
•MSP430 eclipse helios mspgcc4  (German) 
Tip 2: You probably want to install this excellent Eclipse plugin (see screenshot above):
- EmbSysRegView
5. MSPGCC Toolchain
5.1 Compiler options
The msp430-gcc compiler accepts the following MSP430 specific command line 
parameters (copied from the MSPGCC manual page):
-mmcu= Specify the MCU name
-mno-volatile-workaround Do not perform a volatile workaround for bitwise operations.
-mno-stack-init Do not initialize the stack as  main()starts.
-minit-stack= Specify the initial stack address.
-mendup-at= Jump to the specified routine at the end of  main().
-mforce-hwmul Force use of a hardware multiplier.
-mdisable-hwmul Do not use the hardware multiplier.
-minline-hwmulIssue inline code for 32-bit integer operations for devices 
with a hardware multiplier.
-mnoint-hwmulDo not disable and enable interrupts around hardware 
multiplier operations. This makes multiplication faster when 
you are certain no hardware multiplier operations will occur 
at deeper interrupt levels.
-mcall-shiftsUse subroutine calls for shift operations. This may save some
space for shift intensive applications.
1045.2 MCU selection
The following table aims to help selecting the proper MCU name for the -mmcu option 
during the msp430-gcc call:
-mmcu optionProgram
MemoryData
MemoryHardware
Multiplier
Program Memory Size: 1 kB
msp430x110 1 kB128 BNo
msp430x1101 1 kB128 BNo
msp430x2001 1 kB128 BNo
msp430x2002 1 kB128 BNo
msp430x2003 1 kB128 BNo
msp430x2101 1 kB128 BNo
Program Memory Size: 2 kB
msp430x1111 2 kB128 BNo
msp430x2011 2 kB128 BNo
msp430x2012 2 kB128 BNo
msp430x2013 2 kB128 BNo
msp430x2111 2 kB128 BNo
msp430x2112 2 kB128 BNo
msp430x311 2 kB128 BNo
Program Memory Size: 4 kB
msp430x112 4 kB256 BNo
msp430x1121 4 kB256 BNo
msp430x1122 4 kB256 BNo
msp430x122 4 kB256 BNo
msp430x1222 4 kB256 BNo
msp430x2122 4 kB256 BNo
msp430x2121 4 kB256 BNo
msp430x312 4 kB256 BNo
msp430x412 4 kB256 BNo
105Program Memory Size: 8 kB
msp430x123 8 kB256 BNo
msp430x133 8 kB256 BNo
msp430x313 8 kB256 BNo
msp430x323 8 kB256 BNo
msp430x413 8 kB256 BNo
msp430x423 8 kB256 BYes
msp430xE423 8 kB256 BYes
msp430xE4232 8 kB256 BYes
msp430xW423 8 kB256 BNo
msp430x1132 8 kB256 BNo
msp430x1232 8 kB256 BNo
msp430x1331 8 kB256 BNo
msp430x2131 8 kB256 BNo
msp430x2132 8 kB256 BNo
msp430x2232 8 kB512 BNo
msp430x2234 8 kB512 BNo
msp430x233 8 kB1024 BYes
msp430x2330 8 kB1024 BYes
Program Memory Size: 12 kB
msp430xE4242 12 kB512 BYes
msp430x314 12 kB512 BNo
Program Memory Size: 16 kB
msp430x4250 16 kB256 BNo
msp430xG4250 16 kB256 BNo
msp430x135 16 kB512 BNo
msp430x1351 16 kB512 BNo
msp430x155 16 kB512 BNo
msp430x2252 16 kB512 BNo
msp430x2254 16 kB512 BNo
msp430x315 16 kB512 BNo
msp430x325 16 kB512 BNo
msp430x415 16 kB512 BNo
msp430x425 16 kB512 BYes
106msp430xE425 16 kB512 BYes
msp430xW425 16 kB512 BNo
msp430xE4252 16 kB512 BYes
msp430x435 16 kB512 BNo
msp430x4351 16 kB512 BNo
msp430x235 16 kB2048 BYes
msp430x2350 16 kB2048 BYes
Program Memory Size: 24 kB
msp430x4260 24 kB256 BNo
msp430xG4260 24 kB256 BNo
msp430x156 24 kB512 BNo
msp430x4361 24 kB1024 BNo
msp430x436 24 kB1024 BNo
msp430x336 24 kB1024 BYes
Program Memory Size: 32 kB
msp430x4270 32 kB256 BNo
msp430xG4270 32 kB256 BNo
msp430x147 32 kB1024 BYes
msp430x1471 32 kB1024 BYes
msp430x157 32 kB1024 BNo
msp430x167 32 kB1024 BYes
msp430x2272 32 kB1024 BNo
msp430x2274 32 kB1024 BNo
msp430x337 32 kB1024 BYes
msp430x417 32 kB1024 BNo
msp430x427 32 kB1024 BYes
msp430xE427 32 kB1024 BYes
msp430xE4272 32 kB1024 BYes
msp430xW427 32 kB1024 BNo
msp430x437 32 kB1024 BNo
msp430xG437 32 kB1024 BNo
msp430x4371 32 kB1024 BNo
msp430x447 32 kB1024 BYes
msp430x2370 32 kB2048 BYes
107msp430x247 32 kB4096 BYes
msp430x2471 32 kB4096 BYes
msp430x1610 32 kB5120 BYes
Program Memory Size: 41 kB
msp430x5438 41 kB16384 BNo
msp430x5437 41 kB16384 BNo
msp430x5436 41 kB16384 BNo
msp430x5435 41 kB16384 BNo
msp430x5419 41 kB16384 BNo
msp430x5441 kB16384 BNo
Program Memory Size: 48 kB
msp430x1611 48 kB10240 BYes
msp430x248 48 kB4096 BYes
msp430x2481 48 kB4096 BYes
msp430x4783 48 kB2048 BYes
msp430xG438 48 kB2048 BNo
msp430x4784 48 kB2048 B
msp430x148 48 kB2048 BYes
msp430x168 48 kB2048 BYes
msp430x1481 48 kB2048 BYes
msp430x448 48 kB2048 BYes
Program Memory Size: 51 kB
msp430xG4617 51 kB8192 BYes
msp430x2418 51 kB8192 BYes
msp430x2618 51 kB8192 BYes
msp430x2417 51 kB8192 BYes
msp430xG4618 51 kB8192 BYes
msp430x2617 51 kB8192 BYes
Program Memory Size: 54 kB
msp430x1612 54 kB5120 BYes
Program Memory Size: 55 kB
msp430x2619 55 kB4096 BYes
msp430xG4619 55 kB4096 BYes
msp430xG4616 55 kB4096 BYes
108msp430x2416 55 kB4096 BYes
msp430x2419 55 kB4096 BYes
msp430x2616 55 kB4096 BYes
msp430x2410 55 kB4096 BYes
Program Memory Size: 59 kB
msp430x4794 59 kB2560 BYes
msp430x4793 59 kB2560 BYes
msp430x2491 59 kB2048 BYes
msp430x1491 60 kB2048 BYes
msp430x149 60 kB2048 BYes
msp430xG439 59 kB2048 BNo
msp430x249 59 kB2048 BYes
msp430x449 59 kB2048 BYes
msp430x169 59 kB2048 BYes
Note: the program memory size should imperatively match the openMSP430 
configuration.
5.3 Custom linker script
The use of the -mmcu switch is of course NOT mandatory. It is simply a convenient way
to use the pre-existing linker scripts provided with the MSPGCC4 toolchain.
However, if the peripheral address space is larger than the standard 512B of the original 
MSP430 (see the Advanced System Configuration  section), a customized linker script 
MUST be provided.
To create a custom linker script, the simplest way is to start from an existing one:
•The MSPGCC(4) toolchain provides a wide range of examples for all supported 
MSP430 models (see “ msp430/lib/ldscripts/ ” sub-directory in the MSPGCC(4) 
installation directory).
•The openMSP430 project also provide a simple linker script example: 
ldscript_example.x
From there, the script can be modified to match YOUR openMSP430 configuration:
109•In the text (rx) section definition, update the ORIGIN and LENGTH fields to 
match the PROGRAM MEMORY configuration.
•In the data (rwx) section definition, update the ORIGIN field to match the 
PERIPHERAL SPACE  configuration and the LENGTH field to match the DATA
MEMORY configuration.
11010.
File and Directory
Description
Table of content
•1. Introduction 
•2. Directory structure: openMSP430 core  
•3. Directory structure: FGPA projects  
•3.1 Xilinx Spartan 3 example
•3.2 Altera Cyclone II example
•3.3 Actel ProASIC3 example
•4. Directory structure: Software Development Tools  
1. Introduction
To simplify the integration of this IP, the directory structure is based on the OpenCores 
recommendations. 
2. Directory structure: openMSP430 core
core openMSP430 Core top level directory
abc
dbench Top level testbench directory
abc
dverilog
abc
dtb_openMSP430.v Testbench top level module
ram.v RAM verilog model
111registers.vConnections to Core internals for easy 
debugging
dbg_uart_tasks.v UART tasks for the serial debug interface
dbg_i2c_tasks.v I2C tasks for the serial debug interface
dma_tasks.v DMA tasks for direct memory accesses
io_cell.vGeneric I/O cell model for building the 
serial debug interface I2C bus
msp_debug.vTestbench instruction decoder and ASCII 
chain generator for easy debugging
timescale.v Global time scale definition for simulation.
doc Diverse documentation
abcslau049f.pdf MSP430x1xx Family User's Guide
rtl RTL sources
abc
dverilog
abc
dopenMSP430_defines.vopenMSP430 core configuration file 
(Program and Data memory size definition, 
Debug Interface configuration)
openMSP430_undefines.v openMSP430 Verilog `undef file
openMSP430.v openMSP430 top level
omsp_frontend.v Instruction fetch and decode
omsp_execution_unit.v Execution unit
omsp_alu.v ALU
omsp_register_file.v Register file
omsp_mem_backbone.v Memory backbone
omsp_clock_module.v Basic Clock Module
omsp_sfr.v Special function registers
omsp_watchdog.v Watchdog Timer
omsp_multiplier.v 16x16 Hardware Multiplier
omsp_dbg.v Serial Debug Interface main block
omsp_dbg_hwbrk.vSerial Debug Interface hardware breakpoint
unit
omsp_dbg_uart.vSerial Debug Interface UART 
communication block
omsp_dbg_i2c.vSerial Debug Interface I2C communication 
block
omsp_sync_cell.v Simple synchronization module (double flip-
112flop).
omsp_sync_reset.vGeneric Reset synchronizer (double flip-
flop).
omsp_clock_gate.vGeneric Clock gate (NAND2 or LATCH-
AND based).
omsp_clock_mux.vStandard Clock Mux (used in the clock 
module & watchdog timer).
omsp_and_gate.vAND gate module used on sensitive glitch 
free data paths.
omsp_wakeup_cell.v Generic Wake-up module.
omsp_scan_mux.v Scan MUX.
periph Peripherals directory
abc
domsp_gpio.v Digital I/O (Port 1 to 6)
omsp_timerA_defines.
vTimer A configuration file
omsp_timerA_undefin
es.vTimer A Verilog 'undef file
omsp_timerA.v Timer A
template_periph_16b.v Verilog template for 16 bit peripherals
template_periph_8b.v Verilog template for 8 bit peripherals
sim Top level simulations directory
abc
drtl_sim RTL simulations
abc
dbin RTL simulation scripts
abc
dmsp430simMain simulation script for assembler vector
sources (located in the src directory)
msp430sim_cMain simulation script for C vector sources 
(located in the src-c directory).
asm2ihex.shAssembly file compilation (Intel HEX file 
generation)
ihex2mem.tcl Verilog program memory file generation
rtlsim.sh Verilog Icarus simulation script
template.x ASM linker definition file template
template_defs.asmCommon ASM definition file included in all 
“.s43” files
omsp_config.sh oMSP configuration file.
parse_results Script parsing all regression log files and 
generating a combined regression report.
113parse_summariesScript parsing several regression reports 
and generating a summary report..
cov_*Code coverage scripts for NC-Verilog and 
ICM
run For running RTL simulations
abc
drunRun single simulation of a given assembler 
vector
run_c Run single simulation of a given C vector
run_all Run regression of all vectors
run_all_mpyRun regression of all hardware multiplier 
vectors (!!! very long simulation time !!!)
run_disassembleDisassemble the program memory content 
of the latest simulation
run_coverage_analysisPerforms the coverage report merging of 
the regression run and starts ICM for the 
analysis.
load_waveform.sav SAV file for gtkWave
srcRTL simulation vectors sources (ASM 
based)
abc
dldscript_example.x MSPGCC toolchain linker script example
submit.prj ISIM simulator verilog command file
submit.f Verilog simulator command file
core.f Command file listing the CPU files only.
sing-op_*.s43 Single-operand assembler vector files
sing-op_*.v Single-operand verilog stimulus vector files
two-op_*.s43 Two-operand assembler vector files
two-op_*.v Two-operand verilog stimulus vector files
c-jump_*.s43 Jump assembler vector files
c-jump_*.v Jump verilog stimulus vector files
nmi.s43 NMI assembler vector files
nmi.v NMI verilog stimulus vector files
irq*.s43 IRQ assembler vector files
irq*.v IRQ verilog stimulus vector files
cpu_startup_asic.s43 CPU startup assembler vector files
cpu_startup_asic.v CPU startup stimulus vector files
op_modes*.s43 CPU operating modes assembler vector 
114files (CPUOFF , OSCOFF , SCG1)
op_modes*.vCPU operating modes verilog stimulus 
vector files (CPUOFF , OSCOFF , SCG1)
clock_module*.s43 Basic Clock Module assembler vector files
clock_module*.vBasic Clock Module verilog stimulus vector 
files
lp_modes_*.s43 Low Power modes assembler vector files
lp_modes_*.vLow Power modes verilog stimulus vector 
files
dma_*.s43 DMA assembler vector files
dma_*.v DMA verilog stimulus vector files
dbg_*.s43Serial Debug Interface assembler vector 
files
dbg_*.vSerial Debug Interface verilog stimulus 
vector files
sfr.s43 SFR assembler vector files
sfr.v SFR verilog stimulus vector files
gpio_*.s43 Digital I/O assembler vector files
gpio_*.v Digital I/O verilog stimulus vector files
template_periph_*.s43 Peripheral templates assembler vector files
template_periph_*.vPeripheral templates verilog stimulus 
vector files
wdt_*.s43 Watchdog timer assembler vector files
wdt_*.v Watchdog timer verilog stimulus vector files
tA_*.s43 Timer A assembler vector files
tA_*.v Timer A verilog stimulus vector files
mpy_*.s43 16x16 Multiplier assembler vector files
mpy_*.v16x16 Multiplier verilog stimulus vector 
files
scan.s43 Scan test assembler vector files
scan.v Scan test verilog stimulus vector files
src-c RTL simulation vectors sources (C based)
coremask_v1.0 CoreMark benchmark
dhrystone_v2.1 Dhrystone benchmark (“official” version)
dhrystone_4mcu Dhrystone benchmark (MCU adapted)
sandbox Small playground :-)
115synthesis Top level synthesis directory
abc
dsynopsys Synopsys (Design Compiler) directory
abc
drun_syn Run synthesis
run_tmax Run ATPG
synthesis.tcl Main synthesis TCL script
library.tclLoad library, set operating conditions and 
wire load models
read.tcl Read RTL
constraints.tcl Set design constrains
tmax.tcl Main TetraMax (ATPG) script
results Results directory
actelActel synthesis setup for area & speed 
analysis
alteraAltera synthesis setup for area & speed 
analysis
xilinxXilinx synthesis setup for area & speed 
analysis
3. Directory structure: FGPA projects
3.1 Xilinx Spartan 3 example
fpgaopenMSP430 FPGA Projects top level 
directory
abc
dxilinx_diligent_s3boardXilinx FPGA Project based on the 
Diligent Spartan-3 board
abc
dbench Top level testbench directory
abc
dverilog
abc
dtb_openMSP430_fpga.v FPGA testbench top level module
registers.vConnections to Core internals for easy 
debugging
msp_debug.vTestbench instruction decoder and ASCII 
chain generator for easy debugging
glbl.v Xilinx "glbl.v" file
timescale.v Global time scale definition for 
simulation.
116doc Diverse documentation
abc
dboard_user_guide.pdfSpartan-3 FPGA Starter Kit Board User 
Guide
msp430f1121a.pdf msp430f1121a Specification
xapp462.pdfXilinx Digital Clock Managers (DCMs) 
user guide
rtl RTL sources
abc
dverilog
abc
dopenMSP430_fpga.v FPGA top level file
driver_7segment.vFour-Digit, Seven-Segment LED Display 
driver
io_mux.v I/O mux for port function selection.
openmsp430Local copy of the openMSP430 core.  
The *define.v file has been adjusted to the
requirements of the project.
coregen Xilinx's coregen directory
abc
dram_8x512_hi.* 512 Byte RAM (upper byte)
ram_8x512_lo.* 512 Byte RAM (lower byte)
ram_8x2k_hi.* 2 kByte RAM (upper byte)
ram_8x2k_lo.* 2 kByte RAM (lower byte)
sim Top level simulations directory
abc
drtl_sim RTL simulations
abc
dbin RTL simulation scripts
abc
dmsp430sim Main simulation script
ihex2mem.tcl Verilog program memory file generation
rtlsim.sh Verilog Icarus simulation script
run For running RTL simulations
abc
drunRun simulation of a given software 
project
run_disassembleDisassemble the program memory 
content of the latest simulation
src RTL simulation verilog stimulus
abc
dsubmit.f Verilog simulator command file
*.vStimulus vector for the corresponding 
software project
software Software C programs to be loaded in 
117program memory
abc
dledsLEDs blinking application (from the 
CDK4MSP project)
abc
dmakefile
hardware.h
main.c
7seg.h
7seg.c
ta_uartSoftware UART with Timer_A (from the 
CDK4MSP project)
synthesis Top level synthesis directory
abc
dxilinx
abc
d0_create_bitstream.shRun Xilinx ISE synthesis in a Linux 
environment
1_initialize_pmem.shUpdate bitstream's program memory with
a given software ELF file
2_generate_prom_file.sh Generate PROM file
3_program_fpga.shProgram FPGA and on-board flash 
memory
bitstreams
*.bit Bitstream files
*.mcs PROM files
README.jpg README file
scripts
ihex2mem.tclTCL script converting Intel-HEX format 
to Verilog memory file.
impact_generate_pr
om_file.batchiMP ACT TCL script for PROM file 
generation.
impact_program_fp
ga.batchiMP ACT TCL script for programing 
FPGA and on-board flash memory.
memory.bmmFPGA memory description for bitstream's
program memory update
openMSP430_fpga.
ucfUCF file
openMSP430_fpga.
prjRTL file list to be synthesized
xst_verilog.opt Verilog Option File for XST. Among other
118things, the search path to the include files
is specified here.
3.2 Altera Cyclone II example
fpgaopenMSP430 FPGA Projects top level 
directory
abc
daltera_de1_boardAltera FPGA Project based on Cyclone
II Starter Development Board
abc
dREADME README file
bench Top level testbench directory
abcdverilog
abcdtb_openMSP430_fpga.v FPGA testbench top level module
registers.vConnections to Core internals for easy 
debugging
msp_debug.vTestbench instruction decoder and 
ASCII chain generator for easy 
debugging
altsyncram.vAltera verilog model of the altsyncram 
module..
timescale.vGlobal time scale definition for 
simulation.
doc Diverse documentation
abc
dDE1_Board_Schematic.pdfCyclone II FPGA Starter Development 
Board Schematics
DE1_Reference_Manual.pdfCyclone II FPGA Starter Development 
Board Reference Manual
DE1_User_Guide.pdfCyclone II FPGA Starter Development 
Board User Guide
rtl RTL sources
abc
dverilog
abc
dOpenMSP430_fpga.v FPGA top level file
driver_7segment.v Four-Digit, Seven-Segment LED 
119Display driver
io_mux.v I/O mux for port function selection.
ext_de1_sram.vInterface with altera DE1's external 
async SRAM (256kwords x 16bits)
ram16x512.vSingle port RAM generated with the 
megafunction wizard
rom16x2048.vSingle port ROM generated with the 
megafunction wizard
openmsp430Local copy of the openMSP430 core.  
The *define.v file has been adjusted to 
the requirements of the project.
sim Top level simulations directory
abc
drtl_sim RTL simulations
abc
dbin RTL simulation scripts
abcdmsp430sim Main simulation script
ihex2mem.tclVerilog program memory file 
generation
rtlsim.sh Verilog Icarus simulation script
run For running RTL simulations
abcdrunRun simulation of a given software 
project
run_disassembleDisassemble the program memory 
content of the latest simulation
src RTL simulation verilog stimulus
abcdsubmit.f Verilog simulator command file
*.vStimulus vector for the corresponding 
software project
softwareSoftware C programs to be loaded in 
the program memory
abc
dbinSpecific binaries required for software 
development.
abc
dmifwrite.cppThis prog is taken from 
http://www.johnloomis.org/ece595c/not
es/isa/mifwrite.html and slightly 
changed to satisfy quartus6.1 *.mif 
eating engine.
mifwrite.exe  Windows executable.
mifwrite Linux executable.
120memledtestLEDs blinking application (from the 
CDK4MSP project)
synthesis Top level synthesis directory
abc
daltera
abc
dmain.qsf Global Assignments file
main.sof SOF file
OpenMSP430_fpga.qpf Quartus II project file
openMSP430_fpga_top.v RTL file list to be synthesized
3.3 Actel ProASIC3 example
fpgaopenMSP430 FPGA Projects top level 
directory
abc
dactel_m1a3pl_dev_kitActel FPGA Project based on the 
ProASIC3 M1A3PL development kit
abc
dbench Top level testbench directory
abc
dverilog
abc
dtb_openMSP430_fpga.v FPGA testbench top level module
registers.vConnections to Core internals for easy 
debugging
msp_debug.vTestbench instruction decoder and ASCII 
chain generator for easy debugging
dbg_uart_tasks.vUART tasks for the serial debug 
interface.
timescale.vGlobal time scale definition for 
simulation.
proasic3l.v Actel ProASIC3L library file.
DAC121S101.vVerilog model of National's DAC121S101
12 bit DAC
doc Diverse documentation
abc
dM1A3PL_DEV_KIT_QS.pdf Development Kit Quickstart Card
M1IGLOO_StarterKit_v1_5_
UG.pdfDevelopment Kit User's Guide
rtl RTL sources
abc
dverilog
abc
dopenMSP430_fpga.v FPGA top level file
dac_spi_if.v SPI interface to National's DAC121S101 
12112 bit DAC
openmsp430Local copy of the openMSP430 core.  
The *define.v file has been adjusted to the
requirements of the project.
smartgen Xilinx's coregen directory
abcddmem_128B.v 128 Byte RAM (for data memory)
pmem_2kB.v 2 kByte RAM (for program memory)
sim Top level simulations directory
abc
drtl_sim RTL simulations
abc
dbin RTL simulation scripts
abcdmsp430sim Main simulation script
ihex2mem.tcl Verilog program memory file generation
rtlsim.sh Verilog Icarus simulation script
run For running RTL simulations
abcdrunRun simulation of a given software 
project
run_disassembleDisassemble the program memory 
content of the latest simulation
src RTL simulation verilog stimulus
abcdsubmit.f Verilog simulator command file
*.vStimulus vector for the corresponding 
software project
softwareSoftware C programs to be loaded in 
program memory
abc
dspacewar SpaceWar oscilloscope game.
abc
d
synthesis Top level synthesis directory
abcactel
122
dabc
dprepare_implementation.t
clGenerate required files prior synthesis 
and P&R.
synplify.tcl Synplify template for the synthesis run.
libero_designer.tclLibero Designer template for the P&R 
run.
design_files.v RTL file list to be synthesized
design_constraints.pre.sd
cSynthesis timing constraints.
design_constraints.post.s
dcP&R timing constraints.
design_constraints.pdc P&R physical constraints.
1234. Directory structure: Software 
Development Tools
toolsopenMSP430 Software Development 
Tools top level directory
abc
domsp_alias.xmlThis XML file  allows the software 
development tools to identify a 
openMSP430 implementation, and add 
customized extra information (Alias, 
URL, ...).
binContains the main TCL scripts (and the 
windows executable files if generated)
abc
dopenmsp430-loader.tcl Simple command line boot loader
openmsp430-minidebug.tcl Minimalistic debugger with simple GUI
openmsp430-gdbproxy.tclGDB Proxy server to be used together with
MSP430-GDB and the Eclipse, DDD, or 
Insight graphical front-ends
README.TXTREADME file regarding the use of TCL 
scripts in a Windows environment.
lib Common library
abc
dtcl-lib Common TCL library
abcddbg_uart_generic.tclLow level Generic UART communication 
functions
dbg_i2c_usb-iss.tclLow level I2C communication functions for
the USB-ISS adapter
dbg_utils.tclLow level “COMx:” “/dev/tty” 
communication functions
dbg_functions.tclMain utility functions for the openMSP430 
serial debug interface
combobox.tclA combobox listbox widget written in pure 
tcl (from Bryan Oakley)
xml.tcl Simple XML parser (from Keith Vetter).
openmsp430-gdbproxy GDB Proxy server main project directory
abc
dopenmsp430-gdbproxy.tclGDB Proxy server main TCL Script 
(symbolic link with the script in the bin 
directory)
server.tcl TCP/IP Server utility functions. 
124Send/Receive RSP packets from GDB.
commands.tcl RSP command execution functions.
docSome documentation regarding GDB and
the RSP protocol.
abcdew_GDB_RSP.pdfDocument from Bill Gatliff: Embedding 
with GNU: the gdb Remote Serial Protocol
Howto-
GDB_Remote_Serial_Protoc
ol.pdfDocument from Jeremy Bennett 
(Embecosm): Howto: GDB Remote Serial 
Protocol - Writing a RSP Server
125